{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { Manager, methodCall } from \"@okikio/manager/src/index.ts\";\n\n/**\n * Represents a listener callback function\n */\nexport type TypeListenerCallback = ((...args: any) => void);\n\n/** Represents a new event listener consisting of properties like: callback, scope, name */\nexport interface IListener {\n    readonly callback: TypeListenerCallback;\n    readonly scope?: object | null;\n    readonly name: string;\n}\n\n/**\n * Creates a new listener based on {@link IListener | IListener}\n */\nexport const newListener = ({\n    callback = () => { },\n    scope = null,\n    name = \"event\",\n}: IListener): IListener => ({ callback, scope, name });\n\n/** Represents a new event  */\nexport class Event extends Manager<number, IListener> {\n    /** The name of the event */\n    public name: string;\n    constructor(name: string = \"event\") {\n        super();\n        this.name = name;\n    }\n}\n\n/**\n * Helper function to check if a value is an object.\n * Determines whether the value is a pure object (not array, not function, etc.)\n * \n * @param value - The value to check.\n * @returns True if the value is an object, false otherwise.\n * \n * @example\n * // Check if a value is an object\n * const isObj = isObject({ key: 'value' }); // true\n * \n * @example\n * // Check if a value is not an object\n * const isNotObj = isObject('string'); // false\n */\nexport function isObject(value: any): boolean {\n    return value !== null && typeof value === 'object' && !Array.isArray(value);\n}\n\n/**\n * The types of values `EventEmitter.prototype.on(...), EventEmitter.prototype.once(...), and EventEmitter.prototype.off(...)` accept\n */\nexport type TypeEventInput = (string & {}) | object | Array<(string & {})>;\n\n/**\n * An Event Emitter\n * */\nexport class EventEmitter extends Manager<string, Event> {\n    constructor() {\n        super();\n    }\n\n    /** Gets event, if event doesn't exist create a new one */\n    public getEvent(name: string): Event | undefined {\n        let event = this.get(name);\n        if (!(event instanceof Event)) {\n            this.set(name, new Event(name));\n            return this.get(name);\n        }\n\n        return event;\n    }\n\n    /** Creates a listener and adds it to an event */\n    public newListener(\n        name: string,\n        callback: TypeListenerCallback,\n        scope?: object | null\n    ): Event {\n        const event = this.getEvent(name);\n        if (!event) throw new Error(`Can't add listener to event \"${name}\", as event \"${name}\" does not exist.`);\n        \n        event.add(newListener({ name, callback, scope }));\n        return event;\n    }\n\n    /** Adds a listener to a given event */\n    public on(\n        events: TypeEventInput,\n        callback?: TypeListenerCallback | object,\n        scope?: object\n    ): EventEmitter {\n        // If there is no event break\n        if (\n            events === undefined ||\n            events === null\n        ) return this;\n\n        // Create a new event every space\n        if (typeof events === \"string\") events = events.trim().split(/\\s+/);\n\n        let _name: string;\n        let _callback: TypeListenerCallback;\n        let isObj = isObject(events);\n\n        let _scope: object | undefined = isObj ? callback : scope;\n        if (!isObj) _callback = (callback as TypeListenerCallback);\n\n        // Loop through the list of events\n        Object.keys(events).forEach(key => {\n            // Select the name of the event from the list\n            // Remember events can be {String | Object | Array<string>}\n\n            // Check If events is an Object (JSON like Object, and not an Array)\n            const evts = events as Record<PropertyKey, string | TypeListenerCallback>;\n            _name = isObj ? key : evts[key] as string;\n            if (isObj) _callback = evts[key] as TypeListenerCallback;\n\n            this.newListener(_name, _callback, _scope);\n        }, this);\n        return this;\n    }\n\n    /** Removes a listener from an event */\n    public removeListener(\n        name: string,\n        callback?: TypeListenerCallback,\n        scope?: object | null\n    ): Event {\n        let event = this.get(name);\n        if (!callback) throw new Error(\"Callback is required to remove a listener\");\n        if (!event) throw new Error(`Can't remove listener from event \"${name}\", as event \"${name}\" does not exist.`);\n        if (event instanceof Event) {\n            let listener = newListener({ name, callback, scope });\n            event.forEach((value?: IListener, i?: number) => {\n                if (\n                    value && typeof i === \"number\" &&\n                    value.callback === listener.callback &&\n                    value.scope === listener.scope\n                ) return event.remove(i);\n            });\n        }\n\n        return event;\n    }\n\n    /** Remove a listener from a given event, or just completely remove an event */\n    public off(\n        events: TypeEventInput,\n        callback?: TypeListenerCallback | object,\n        scope?: object\n    ): EventEmitter {\n        // If there is no event break\n        if (\n            events === undefined ||\n            events === null\n        ) return this;\n\n        // Create a new event every space\n        if (typeof events === \"string\") events = events.trim().split(/\\s+/);\n\n        let _name: string;\n        let _callback: TypeListenerCallback;\n        let isObj = isObject(events);\n\n        let _scope: object | undefined = isObj ? (callback as object) : scope;\n        if (!isObj) _callback = (callback as TypeListenerCallback);\n\n        // Loop through the list of events\n        Object.keys(events).forEach(key => {\n            // Select the name of the event from the list\n            // Remember events can be {String | Object | Array<any>}\n\n            // Check If events is an Object (JSON like Object, and not an Array)\n            const evts = events as Record<PropertyKey, string | TypeListenerCallback>;\n            _name = isObj ? key : evts[key] as string;\n            if (isObj) _callback = evts[key] as TypeListenerCallback;\n\n            if (typeof _callback === \"function\") {\n                this.removeListener(_name, _callback, _scope);\n            } else this.remove(_name);\n        }, this);\n        return this;\n    }\n\n    /**\n     * Adds a one time event listener for an event\n     */\n    public once(\n        events: TypeEventInput,\n        callback?: TypeListenerCallback | object,\n        scope?: object\n    ): EventEmitter {\n        // If there is no event break\n        if (\n            events === undefined ||\n            events === null\n        ) return this;\n\n        // Create a new event every space\n        if (typeof events == \"string\") events = events.trim().split(/\\s+/);\n\n        let isObj = isObject(events);\n\n        // Loop through the list of events\n        Object.keys(events).forEach(key => {\n            // Select the name of the event from the list\n            // Remember events can be {String | Object | Array<string>}\n            // Check If events is an Object (JSON like Object, and not an Array)\n            const evts = events as Record<PropertyKey, string | TypeListenerCallback>;\n            let _name: string = isObj ? key : (evts[key] as string);\n            let _callback: TypeListenerCallback = isObj ? (evts[key] as TypeListenerCallback) : (callback as TypeListenerCallback);\n            let _scope: object | undefined = isObj ? callback : scope;\n            let onceFn: TypeListenerCallback = (...args) => {\n                _callback.apply(_scope, args);\n                this.removeListener(_name, onceFn, _scope);\n            };\n\n            this.newListener(_name, onceFn, _scope);\n        }, this);\n        return this;\n    }\n\n    /** Call all listeners within an event */\n    public emit(\n        events: string | Array<any>,\n        ...args: any\n    ): EventEmitter {\n        // If there is no event break\n        if (\n            events === undefined ||\n            events === null\n        ) return this;\n\n        // Create a new event every space\n        if (typeof events == \"string\") events = events.trim().split(/\\s+/);\n\n        // Loop through the list of events\n        events.forEach((event: string) => {\n            let _event: Event | undefined = this.get(event);\n            if (_event instanceof Event) {\n                _event.forEach((listener?: IListener) => {\n                    if (!listener) return;\n                    let { callback, scope } = listener;\n                    callback.apply(scope, args);\n                });\n            }\n        }, this);\n        return this;\n    }\n\n    /** Clears events and event listeners */\n    public clear() {\n        methodCall(this, \"clear\");\n        super.clear();\n        return this;\n    }\n}\n\n/**\n * Adds event listeners to an EventTarget.\n * \n * @param {EventTarget} target - The target to attach event listeners to.\n * @param {(string | Array<string> | Record<PropertyKey, string | EventListenerOrEventListenerObject | null>)} events - The events to listen for. Can be a string, an array of strings, or an object with event names as keys.\n * @param {EventListenerOrEventListenerObject | null | boolean | AddEventListenerOptions} [callback] - The callback function or options for the event listener.\n * @param {boolean | AddEventListenerOptions} [opts] - Additional options for the event listener.\n * @returns {EventTarget | null} The target if successful, or null if there was an error.\n * \n * @example\n * // Single event with a callback\n * on(document.body, 'click', (e) => console.log('Body clicked!', e));\n * \n * @example\n * // Multiple events with a single callback\n * on(document.body, ['click', 'mouseover'], (e) => console.log('Event triggered!', e));\n * \n * @example\n * // Event object with different callbacks\n * on(document.body, {\n *   click: (e) => console.log('Body clicked!', e),\n *   mouseover: (e) => console.log('Mouse over body!', e)\n * });\n * \n * @example\n * // Event handler object with a handle method\n * on(document.body, 'click', { handle: (e) => console.log('Handled click event!', e) });\n * \n * @example\n * // Event with options (once: true)\n * on(document.body, 'click', (e) => console.log('Body clicked once!', e), { once: true });\n * \n * @example\n * // Event with options (capture: true)\n * on(document.body, 'click', (e) => console.log('Body clicked with capture!', e), { capture: true });\n * \n * @example\n * // Event with options (passive: true)\n * on(document.body, 'click', (e) => console.log('Body clicked with passive option!', e), { passive: true });\n */\nexport function on(\n    target: EventTarget,\n    events: (string & {}) | Array<(string & {})> | Record<PropertyKey, string | EventListenerOrEventListenerObject | null>,\n    callback?: EventListenerOrEventListenerObject | null | boolean | AddEventListenerOptions,\n    opts?: boolean | AddEventListenerOptions\n): EventTarget | null {\n    // If there is no event or target, break\n    if (target === undefined || target === null) return null;\n    if (events === undefined || events === null) return target;\n\n    // Create a new event every space\n    if (typeof events === \"string\") events = events.trim().split(/\\s+/);\n\n    let _name: string;\n    let _callback: EventListenerOrEventListenerObject;\n    let isObj = isObject(events);\n\n    let _opts = isObj ? (callback as boolean | AddEventListenerOptions) : opts;\n    if (!isObj) _callback = (callback as EventListenerOrEventListenerObject);\n\n    // Loop through the list of events\n    Object.keys(events).forEach(key => {\n        // Select the name of the event from the list\n        // Remember events can be {String | Object | Array<string>}\n        const evts = events as Record<PropertyKey, string | EventListenerOrEventListenerObject>;\n        _name = isObj ? key : evts[key] as string;\n        if (isObj) _callback = evts[key] as EventListenerOrEventListenerObject;\n\n        target.addEventListener(_name, _callback, _opts);\n    }, target);\n    return target;\n}\n\n/**\n * Removes event listeners from an EventTarget.\n * \n * @param {EventTarget} target - The target to remove event listeners from.\n * @param {(string | Array<string> | Record<PropertyKey, string | EventListenerOrEventListenerObject | null>)} events - The events to stop listening for. Can be a string, an array of strings, or an object with event names as keys.\n * @param {EventListenerOrEventListenerObject | null | boolean | EventListenerOptions} [callback] - The callback function or options for the event listener.\n * @param {boolean | EventListenerOptions} [opts] - Additional options for the event listener.\n * @returns {EventTarget | null} The target if successful, or null if there was an error.\n * \n * @example\n * // Single event with a callback\n * off(document.body, 'click', handleClick);\n * \n * @example\n * // Multiple events with a single callback\n * off(document.body, ['click', 'mouseover'], handleEvent);\n * \n * @example\n * // Event object with different callbacks\n * off(document.body, {\n *   click: handleClick,\n *   mouseover: handleMouseOver\n * });\n * \n * @example\n * // Event with options (once: true)\n * off(document.body, 'click', handleClick, { once: true });\n */\nexport function off(\n    target: EventTarget,\n    events: (string & {}) | Array<(string & {})> | Record<PropertyKey, string | EventListenerOrEventListenerObject | null>,\n    callback?: EventListenerOrEventListenerObject | null | boolean | EventListenerOptions,\n    opts?: boolean | EventListenerOptions\n): EventTarget | null {\n    // If there is no event or target, break\n    if (target === undefined || target === null) return null;\n    if (events === undefined || events === null) return target;\n\n    // Create a new event every space\n    if (typeof events === \"string\") events = events.trim().split(/\\s+/);\n\n    let _name: string;\n    let _callback: EventListenerOrEventListenerObject;\n    let isObj = isObject(events);\n\n    let _opts = isObj ? (callback as boolean | EventListenerOptions) : opts;\n    if (!isObj) _callback = (callback as EventListenerOrEventListenerObject);\n\n    // Loop through the list of events\n    Object.keys(events).forEach(key => {\n        // Select the name of the event from the list\n        // Remember events can be {String | Object | Array<string>}\n        const evts = events as Record<PropertyKey, string | EventListenerOrEventListenerObject>;\n        _name = isObj ? key : evts[key] as string;\n        if (isObj) _callback = evts[key] as EventListenerOrEventListenerObject;\n\n        target.removeEventListener(_name, _callback, _opts);\n    }, target);\n    return target;\n}\n\n/**\n * Dispatches events on an EventTarget.\n * \n * @param {EventTarget} target - The target to dispatch events on.\n * @param {(globalThis.Event | string | Array<(globalThis.Event | string) & {})>} events - The events to dispatch. Can be an Event object, a string, or an array of strings or Event objects.\n * @returns {EventTarget | null} The target if successful, or null if there was an error.\n * \n * @example\n * // Single event as string\n * emit(document.body, 'customEvent');\n * \n * @example\n * // Single event as Event object\n * const event = new Event('customEvent');\n * emit(document.body, event);\n * \n * @example\n * // Multiple events as strings\n * emit(document.body, ['customEvent1', 'customEvent2']);\n * \n * @example\n * // Multiple events as Event objects\n * const event1 = new Event('customEvent1');\n * const event2 = new Event('customEvent2');\n * emit(document.body, [event1, event2]);\n */\nexport function emit(\n    target: EventTarget,\n    events: globalThis.Event | (string & {}) | Array<(globalThis.Event | string & {})>\n): EventTarget | null {\n    // If there is no event or target, break\n    if (target === undefined || target === null) return null;\n    if (events === undefined || events === null) return target;\n\n    // Create a new event every space\n    if (typeof events === \"string\") events = events.trim().split(/\\s+/);\n    if (events instanceof globalThis.Event) events = [events];\n\n    // Loop through the list of events\n    events.forEach(event => {\n        // Select the name of the event from the list\n        // Remember events can be {String | Array<string>}\n        const _event = event instanceof globalThis.Event ? event : new globalThis.Event(event);\n        target.dispatchEvent(_event);\n    }, target);\n    return target;\n}\n\n/**\n * Converts a list of event names to CustomEvent objects.\n * \n * @param {(string | Array<string>)} events - The events to convert. Can be a string or an array of strings.\n * @param {T} detail - The detail to include in the CustomEvent.\n * @returns {Array<CustomEvent<T>>} An array of CustomEvent objects.\n * \n * @example\n * // Single event with detail\n * const customEvents = toCustomEvents('customEvent', { key: 'value' });\n * customEvents.forEach(event => document.body.dispatchEvent(event));\n * \n * @example\n * // Multiple events with detail\n * const customEvents = toCustomEvents(['customEvent1', 'customEvent2'], { key: 'value' });\n * customEvents.forEach(event => document.body.dispatchEvent(event));\n */\nexport function toCustomEvents<T = any>(events: (string & {}) | Array<(string & {})>, detail: T) {\n    // Create a new event every space\n    if (typeof events === \"string\") events = events.trim().split(/\\s+/);\n\n    return events.map((evt) => {\n        return new CustomEvent(evt, { detail });\n    });\n}\n\nexport default EventEmitter;\n"],"mappings":"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","names":[]}