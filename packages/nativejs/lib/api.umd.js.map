{"version":3,"file":"api.umd.js","sources":["../src/config.ts","../node_modules/.pnpm/managerjs@1.1.8/node_modules/managerjs/src/api.ts","../src/manager.ts","../src/url.ts","../src/history.ts","../src/page.ts","../node_modules/.pnpm/@okikio/event-emitter@1.1.3/node_modules/@okikio/event-emitter/src/api.ts","../src/service.ts","../src/transition.ts","../src/block.ts","../src/app.ts","../src/pjax.ts"],"sourcesContent":["// The config variables\r\nexport interface ICONFIG {\r\n    prefix?: string;\r\n    wrapperAttr?: string;\r\n    noAjaxLinkAttr?: string;\r\n    noPrefetchAttr?: \"no-prefetch\";\r\n    headers?: string[][];\r\n    preventSelfAttr?: string;\r\n    preventAllAttr?: string;\r\n    transitionAttr?: string;\r\n    blockAttr?: string;\r\n    timeout?: number\r\n}\r\n\r\nexport const CONFIG_DEFAULTS: ICONFIG = {\r\n    wrapperAttr: \"wrapper\",\r\n    noAjaxLinkAttr: \"no-ajax-link\",\r\n    noPrefetchAttr: \"no-prefetch\",\r\n    headers: [\r\n        [\"x-partial\", \"true\"]\r\n    ],\r\n    preventSelfAttr: `prevent=\"self\"`,\r\n    preventAllAttr: `prevent=\"all\"`,\r\n    transitionAttr: \"transition\",\r\n    blockAttr: `block`,\r\n    timeout: 30000\r\n};\r\n\r\nexport type ConfigKeys = keyof ICONFIG;\r\n\r\n/**\r\n * The Config class\r\n *\r\n * @export\r\n * @class CONFIG\r\n */\r\nexport class CONFIG {\r\n    /**\r\n     * The current Configuration\r\n     *\r\n     * @protected\r\n     * @type ICONFIG\r\n     * @memberof CONFIG\r\n     */\r\n    protected config: ICONFIG;\r\n\r\n    /**\r\n     * Creates an instance of CONFIG.\r\n     *\r\n     * @param {ICONFIG} config\r\n     * @memberof CONFIG\r\n     */\r\n    constructor(config: ICONFIG) {\r\n        this.config = Object.assign({ ...CONFIG_DEFAULTS }, config);\r\n    }\r\n\r\n    /**\r\n     * Converts string into data attributes\r\n     *\r\n     * @param {string} value\r\n     * @param {boolean} brackets [brackets=true]\r\n     * @returns string\r\n     * @memberof CONFIG\r\n     */\r\n    public toAttr(value: string, brackets: boolean = true): string {\r\n        let { prefix } = this.config;\r\n        let attr = `data${prefix ? \"-\" + prefix : \"\"}-${value}`;\r\n        return brackets ? `[${attr}]` : attr;\r\n    }\r\n\r\n    /**\r\n     * Selects config vars, and formats them for use, or simply returns the current configurations for the framework\r\n     *\r\n     * @param {ConfigKeys} value\r\n     * @param {boolean} [brackets=true]\r\n     * @returns any\r\n     * @memberof CONFIG\r\n     */\r\n    public getConfig(value?: ConfigKeys, brackets: boolean = true): any {\r\n        if (typeof value !== \"string\")\r\n            return this.config;\r\n\r\n        let config = this.config[value];\r\n        if (typeof config === \"string\")\r\n            return this.toAttr(config, brackets);\r\n        return config;\r\n    }\r\n}","\r\n/**\r\n * Manages complex lists of named data, eg. A page can be stored in a list by of other pages with the url being how the page is stored in the list. Managers use Maps to store data.\r\n *\r\n * @export\r\n * @class Manager\r\n * @template K\r\n * @template V\r\n */\r\nexport class Manager<K, V> {\r\n\t/**\r\n\t * The complex list of named data, to which the Manager controls\r\n\t *\r\n\t * @protected\r\n\t * @type Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tprotected map: Map<K, V>;\r\n\r\n    /**\r\n     * Creates an instance of Manager.\r\n     * \r\n     * @param {Array<[K, V]>} [value]\r\n     * @memberof Manager\r\n     */\r\n\tconstructor(value?: Array<[K, V]>) {\r\n\t\tthis.map = new Map(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Manager class's list\r\n\t *\r\n\t * @returns Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic getMap(): Map<K, V> {\r\n\t\treturn this.map;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key to find in the Manager's list\r\n\t * @returns V\r\n\t */\r\n\tpublic get(key: K): V {\r\n\t\treturn this.map.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the keys of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<K>\r\n     * @memberof Manager\r\n     */\r\n\tpublic keys(): Array<K> {\r\n\t\treturn [...this.map.keys()];\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the values of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<V>\r\n     * @memberof Manager\r\n\t */\r\n\tpublic values(): Array<V> {\r\n\t\treturn [...this.map.values()];\r\n\t}\r\n\r\n\t/**\r\n\t * Set a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key where the value will be stored\r\n\t * @param  {V} value - The value to store\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic set(key: K, value: V): Manager<K, V> {\r\n\t\tthis.map.set(key, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n    /**\r\n     * Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers\r\n     *\r\n     * @public\r\n     * @param  {V} value\r\n     * @returns Manager<K, V>\r\n     */\r\n\tpublic add(value: V): Manager<K, V> {\r\n\t\t// @ts-ignore\r\n\t\tthis.set(this.size as K, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the total number of items stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @returns Number\r\n\t */\r\n\tpublic get size(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n    /**\r\n\t * Returns the last item in the Manager who's index is a certain distance from the last item in the Manager\r\n     *\r\n     * @param {number} [distance=1]\r\n     * @returns V | undefined\r\n     * @memberof Manager\r\n     */\r\n\tpublic last(distance: number = 1): V | undefined {\r\n\t\tlet key = this.keys()[this.size - distance];\r\n\t\treturn this.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the second last item in the Manager\r\n\t *\r\n\t * @public\r\n\t * @returns V | undefined\r\n\t */\r\n\tpublic prev(): V | undefined {\r\n\t\treturn this.last(2);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes a value stored in the Manager, via the key\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key for the key value pair to be removed\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic delete(key: K): Manager<K, V> {\r\n\t\tthis.map.delete(key);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Clear the Manager of all its contents\r\n\t *\r\n\t * @public\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic clear(): Manager<K, V> {\r\n\t\tthis.map.clear();\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the Manager contains a certain key\r\n\t *\r\n\t * @public\r\n\t * @param {K} key\r\n\t * @returns boolean\r\n\t */\r\n\tpublic has(key: K): boolean {\r\n\t\treturn this.map.has(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order.\r\n\t *\r\n\t * @public\r\n\t * @returns IterableIterator<[K, V]>\r\n\t */\r\n\tpublic entries(): IterableIterator<[K, V]> {\r\n\t\treturn this.map.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates through the Managers contents, calling a callback function every iteration\r\n\t *\r\n\t * @param {*} [callback=(...args: any): void => { }]\r\n\t * @param {object} context\r\n\t * @returns Manager<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic forEach(\r\n\t\tcallback: any = (...args: any): void => { },\r\n\t\tcontext?: object\r\n\t): Manager<K, V> {\r\n\t\tthis.map.forEach(callback, context);\r\n\t\treturn this;\r\n\t}\r\n\r\n    /**\r\n     * Allows iteration via the for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators]\r\n     *\r\n     * @returns\r\n     * @memberof Manager\r\n     */\r\n\tpublic [Symbol.iterator]() {\r\n\t\treturn this.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the method of a certain name for all items that are currently installed\r\n\t *\r\n\t * @param {string} method\r\n\t * @param {Array<any>} [args=[]]\r\n\t * @returns Manager<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic methodCall(method: string, ...args: any): Manager<K, V> {\r\n\t\tthis.forEach((item: V) => {\r\n\t\t\titem[method](...args);\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\r\n\t *\r\n\t * @param {string} method\r\n\t * @param {Array<any>} [args=[]]\r\n\t * @returns Promise<Manager<K, V>>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic async asyncMethodCall(method: string, ...args: any): Promise<Manager<K, V>> {\r\n\t\tfor await (let [, item] of this.map) {\r\n\t\t\tawait item[method](...args);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { Manager } from \"managerjs/src/api\";\r\nimport { ConfigKeys } from \"./config\";\r\nimport { App } from \"./app\";\r\n\r\nexport type IAdvancedManager = AdvancedManager<any, ManagerItem>;\r\n\r\n/**\r\n * The base class for all AdvancedManager and AdvancedStorage items\r\n *\r\n * @export\r\n * @class ManagerItem\r\n */\r\nexport class ManagerItem {\r\n    /**\r\n     * The AdvancedManager or AdvancedStorage the ManagerItem is attached to\r\n     *\r\n     * @protected\r\n     * @type IAdvancedManager\r\n     * @memberof ManagerItem\r\n     */\r\n    protected manager: IAdvancedManager;\r\n\r\n    /**\r\n     * Creates an instance of ManagerItem.\r\n     * \r\n     * @memberof ManagerItem\r\n     */\r\n    constructor() { }\r\n\r\n    /**\r\n     * The getConfig method for accessing the Configuration of the current App\r\n     *\r\n     * @param {ConfigKeys} [value]\r\n     * @param {boolean} [brackets]\r\n     * @returns any\r\n     * @memberof ManagerItem\r\n     */\r\n    protected getConfig(value?: ConfigKeys, brackets?: boolean): any {\r\n        return this.manager.getConfig(value, brackets);\r\n    };\r\n\r\n    /**\r\n     * Run after the Manager Item has been registered\r\n     *\r\n     * @returns any\r\n     * @memberof ManagerItem\r\n     */\r\n    public install(): any { }\r\n\r\n    /**\r\n     * Register the current Manager Item's manager\r\n     *\r\n     * @param {IAdvancedManager} manager\r\n     * @returns ManagerItem\r\n     * @memberof ManagerItem\r\n     */\r\n    public register(manager: IAdvancedManager): ManagerItem {\r\n        this.manager = manager;\r\n        this.install();\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * A tweak to the Manager class that makes it self aware of the App class it's instantiated in\r\n *\r\n * @export\r\n * @class AdvancedManager\r\n * @extends {Manager<K, V>}\r\n * @template K\r\n * @template V\r\n */\r\nexport class AdvancedManager<K, V extends ManagerItem> extends Manager<K, V> {\r\n\t/**\r\n\t * The instance of the App class, the Manager is instantiated in\r\n\t *\r\n\t * @private\r\n\t * @type App\r\n\t * @memberof AdvancedManager\r\n\t */\r\n    private app: App;\r\n\r\n\t/**\r\n\t * Creates an instance of AdvancedManager.\r\n\t *\r\n\t * @param {App} app - The instance of the App class, the Manager is instantiated in\r\n\t * @memberof AdvancedManager\r\n\t */\r\n    constructor(app: App) {\r\n        super();\r\n        this.app = app;\r\n    }\r\n\r\n\t/**\r\n\t * Set a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key where the value will be stored\r\n\t * @param  {V} value - The value to store\r\n\t * @returns AdvancedManager<K, V>\r\n\t */\r\n    public set(key: K, value: V) {\r\n        super.set(key, value);\r\n        typeof value.register === \"function\" && value.register(this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the instance the App class\r\n\t *\r\n\t * @returns App\r\n\t * @memberof AdvancedManager\r\n\t */\r\n    public getApp(): App {\r\n        return this.app;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the App config\r\n\t *\r\n     * @param {...any} args\r\n     * @returns any\r\n\t * @memberof AdvancedManager\r\n\t */\r\n    public getConfig(...args: any): any {\r\n        return this.app.getConfig(...args);\r\n    }\r\n}\r\n\r\nexport { Manager };","/**\r\n * Adds new methods to the native URL Object; it seemed cleaner than using a custom method or editing the prototype.\r\n *\r\n * This doesn't extend the **Class** object because it's meant to be a small extension of the native URL class.\r\n *\r\n * @export\r\n * @class _URL\r\n * @extends {URL}\r\n */\r\nexport class _URL extends URL {\r\n    // Read up on the native URL class [devdocs.io/dom/url]\r\n\t/**\r\n\t * Creates an instance of _URL.\r\n\t *\r\n     * @param {(string | _URL | URL | Location)} [url=window.location.pathname]\r\n\t * @memberof _URL\r\n\t */\r\n    constructor(url: any = window.location.href) {\r\n        super(url instanceof URL ? url.href : url, window.location.origin);\r\n    }\r\n\r\n    /**\r\n     * Returns the pathname with the hash\r\n     *\r\n     * @returns string\r\n     * @memberof _URL\r\n     */\r\n    public getFullPath(): string {\r\n        return `${this.pathname}${this.hash}`;\r\n    }\r\n\r\n    /**\r\n     * Returns the actual hash without the hashtag\r\n     *\r\n     * @returns string\r\n     * @memberof _URL\r\n     */\r\n    public getHash(): string {\r\n        return this.hash.slice(1);\r\n    }\r\n\r\n    /**\r\n\t * Removes the hash from the full URL for a clean URL string\r\n\t *\r\n\t * @returns string\r\n\t * @memberof _URL\r\n\t */\r\n    public clean(): string {\r\n        return this.toString().replace(/(\\/#.*|\\/|#.*)$/, '');\r\n    }\r\n\r\n\t/**\r\n\t * Returns the pathname of a URL\r\n\t *\r\n\t * @returns string\r\n\t * @memberof _URL\r\n\t */\r\n    public getPathname(): string {\r\n        return this.pathname;\r\n    }\r\n\r\n\t/**\r\n\t * Compares this **_URL** to another **_URL**\r\n\t *\r\n\t * @param {_URL} url\r\n\t * @returns boolean\r\n\t * @memberof _URL\r\n\t */\r\n    public equalTo(url: _URL): boolean {\r\n        return this.clean() == url.clean();\r\n    }\r\n\r\n\t/**\r\n\t * Compares the pathname of two URLs to each other\r\n\t *\r\n\t * @static\r\n\t * @param {_URL} a\r\n\t * @param {_URL} b\r\n\t * @returns boolean\r\n\t * @memberof _URL\r\n\t */\r\n    static equal(a: _URL | string, b: _URL | string): boolean {\r\n        let urlA = a instanceof _URL ? a : new _URL(a);\r\n        let urlB = b instanceof _URL ? b : new _URL(b);\r\n        return urlA.equalTo(urlB);\r\n    }\r\n}\r\n\r\n/**\r\n * This is the default starting URL, to avoid needless instances of the same class that produce the same value, I defined the default value\r\n */\r\nexport const newURL = new _URL();\r\nexport const URLString = newURL.getPathname();","import { Manager } from \"./manager\";\r\nimport { _URL } from \"./url\";\r\n\r\nexport type Trigger = HTMLAnchorElement | \"HistoryManager\" | \"popstate\" | \"back\" | \"forward\";\r\n\r\nexport interface ICoords {\r\n\treadonly x: number;\r\n\treadonly y: number;\r\n}\r\n\r\nexport interface IStateData {\r\n\tscroll: ICoords;\r\n\t[key: string]: any;\r\n}\r\n\r\nexport interface IState {\r\n\turl: _URL;\r\n\tindex?: number;\r\n\ttransition: string;\r\n\tdata: IStateData;\r\n}\r\n\r\n/**\r\n * A quick snapshot of page coordinates, e.g. scroll positions\r\n *\r\n * @export\r\n * @class Coords\r\n * @implements {ICoords}\r\n */\r\nexport class Coords implements ICoords {\r\n\tpublic x: number;\r\n\tpublic y: number;\r\n\r\n\t/**\r\n\t * Creates an instance of Coords.\r\n\t *\r\n\t * @param {number} [x=window.scrollX]\r\n\t * @param {number} [y=window.scrollY]\r\n\t * @memberof Coords\r\n\t */\r\n\tconstructor(x: number = window.scrollX, y: number = window.scrollY) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n}\r\n\r\n/**\r\n * Represents the current status of the page consisting of properties like: url, transition, and data\r\n *\r\n * @export\r\n * @class State\r\n */\r\nexport class State {\r\n\t/**\r\n\t * The current state data\r\n\t *\r\n\t * @private\r\n\t * @type IState\r\n\t * @memberof State\r\n\t */\r\n\tprivate state: IState;\r\n\r\n\t/**\r\n\t * Creates an instance of State.\r\n\t * @param {IState} {\r\n     *         url = new _URL(),\r\n\t *         index = 0,\r\n\t *         transition = \"default\",\r\n\t *         data = {\r\n\t *             scroll: new StateCoords(),\r\n\t *             trigger: \"HistoryManager\"\r\n\t *         }\r\n\t *     }\r\n\t * @memberof State\r\n\t */\r\n\tconstructor(state: IState = {\r\n\t\turl: new _URL(),\r\n\t\tindex: 0,\r\n\t\ttransition: \"default\",\r\n\t\tdata: {\r\n\t\t\tscroll: new Coords(),\r\n\t\t\ttrigger: \"HistoryManager\"\r\n\t\t}\r\n\t}) {\r\n\t\tthis.state = state;\r\n\t}\r\n\r\n\t/**\r\n\t * Get state index\r\n\t *\r\n\t * @returns number\r\n\t * @memberof State\r\n\t */\r\n\tpublic getIndex(): number {\r\n\t\treturn this.state.index;\r\n\t}\r\n\r\n\t/**\r\n\t * Set state index\r\n\t *\r\n\t * @param {number} index\r\n\t * @returns State\r\n\t * @memberof State\r\n\t */\r\n\tpublic setIndex(index: number): State {\r\n\t\tthis.state.index = index;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Get state URL\r\n\t *\r\n\t * @returns _URL\r\n\t * @memberof State\r\n\t */\r\n\tpublic getURL(): _URL {\r\n\t\treturn this.state.url;\r\n\t}\r\n\r\n\t/**\r\n\t * Get state URL as a string\r\n\t *\r\n\t * @returns string\r\n\t * @memberof State\r\n\t */\r\n\tpublic getURLPathname(): string {\r\n\t\treturn this.state.url.getPathname();\r\n\t}\r\n\r\n\t/**\r\n\t * Get state transition\r\n\t *\r\n\t * @returns string\r\n\t * @memberof State\r\n\t */\r\n\tpublic getTransition(): string {\r\n\t\treturn this.state.transition;\r\n\t}\r\n\r\n\t/**\r\n\t * Get state data\r\n\t *\r\n\t * @returns IStateData\r\n\t * @memberof State\r\n\t */\r\n\tpublic getData(): IStateData {\r\n\t\treturn this.state.data;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the State as an Object\r\n\t *\r\n\t * @returns object\r\n\t * @memberof State\r\n\t */\r\n\tpublic toJSON(): object {\r\n\t\tconst { url, index, transition, data }: IState = this.state;\r\n\t\treturn {\r\n\t\t\turl: url.getFullPath(), index, transition, data\r\n\t\t};\r\n\t}\r\n}\r\n\r\n/**\r\n * History of the site, stores only the State class\r\n *\r\n * @export\r\n * @class HistoryManager\r\n * @extends {Manager<number, State>}\r\n */\r\nexport class HistoryManager extends Manager<number, State> {\r\n\t/**\r\n\t * Creates an instance of the HistoryManager class, which inherits properties and methods from the Storage class.\r\n\t *\r\n\t * @memberof HistoryManager\r\n\t * @constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the index of the state before adding to HistoryManager\r\n\t *\r\n\t * @param {State} value\r\n\t * @returns HistoryManager\r\n\t * @memberof HistoryManager\r\n\t */\r\n\tpublic add(value: State): HistoryManager {\r\n\t\tlet state = value;\r\n\t\tlet index = this.size;\r\n\t\tsuper.add(state);\r\n\t\tstate.setIndex(index);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Quick way to add a State to the HistoryManager\r\n\t *\r\n\t * @param {IState} value\r\n\t * @returns HistoryManager\r\n\t * @memberof HistoryManager\r\n\t */\r\n\tpublic addState(value: IState | State): HistoryManager {\r\n\t\tlet state = value instanceof State ? value : new State(value);\r\n\t\tthis.add(state);\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { Manager, ManagerItem, AdvancedManager } from \"./manager\";\r\nimport { _URL, URLString } from \"./url\";\r\nimport { App } from \"./app\";\r\n\r\n/**\r\n * Parses strings to DOM\r\n */\r\nexport const PARSER: DOMParser = new DOMParser();\r\n\r\n/**\r\n * A page represents the DOM elements that create each page\r\n *\r\n * @export\r\n * @class Page\r\n */\r\nexport class Page extends ManagerItem {\r\n\t/**\r\n\t * Holds the DOM of the current page\r\n\t *\r\n\t * @private\r\n\t * @type Document\r\n\t * @memberof Page\r\n\t */\r\n    private dom: Document;\r\n\r\n\t/**\r\n\t * Holds the wrapper element to be swapped out of each Page\r\n\t *\r\n\t * @private\r\n\t * @type HTMLElement\r\n\t * @memberof Page\r\n\t */\r\n    private wrapper: HTMLElement;\r\n\r\n\t/**\r\n\t * Holds the title of each page\r\n\t *\r\n\t * @private\r\n\t * @type string\r\n\t * @memberof Page\r\n\t */\r\n    private title: string;\r\n\r\n\t/**\r\n\t * Holds the head element of each page\r\n\t *\r\n\t * @private\r\n\t * @type Element\r\n\t * @memberof Page\r\n\t */\r\n    private head: Element;\r\n\r\n\t/**\r\n\t * Holds the body element of each page\r\n\t *\r\n\t * @private\r\n\t * @type Element\r\n\t * @memberof Page\r\n\t */\r\n    private body: Element;\r\n\r\n\t/**\r\n\t * The URL of the current page\r\n\t *\r\n\t * @private\r\n\t * @type _URL\r\n\t * @memberof Page\r\n\t */\r\n    private url: _URL;\r\n\r\n\t/**\r\n\t * Creates an instance of Page, it also creates a new page from response text, or a Document Object\r\n\t *\r\n\t * @param {_URL} [url=new _URL()]\r\n\t * @param {(string | Document)} [dom=document]\r\n\t * @memberof Page\r\n\t */\r\n    constructor(url: _URL = new _URL(), dom: string | Document = document) {\r\n        super();\r\n        this.url = url;\r\n        if (typeof dom === \"string\") {\r\n            this.dom = PARSER.parseFromString(dom, \"text/html\");\r\n        } else this.dom = dom || document;\r\n\r\n        const { title, head, body } = this.dom;\r\n        this.title = title;\r\n        this.head = head;\r\n        this.body = body;\r\n    }\r\n\r\n    /**\r\n     * Runs once the the manager and config have been registered\r\n     *\r\n     * @returns void\r\n     * @memberof Page\r\n     */\r\n    public install(): void {\r\n        this.wrapper = this.body.querySelector(this.getConfig(\"wrapperAttr\"));\r\n    }\r\n\r\n\t/**\r\n\t * Returns the current page's URL\r\n\t *\r\n\t * @returns _URL\r\n\t * @memberof Page\r\n\t */\r\n    public getURL(): _URL {\r\n        return this.url;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the current page's URL\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Page\r\n\t */\r\n    public getPathname(): string {\r\n        return this.url.pathname;\r\n    }\r\n\r\n\t/**\r\n\t * The page title\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Page\r\n\t */\r\n    public getTitle(): string {\r\n        return this.title;\r\n    }\r\n\r\n\t/**\r\n\t * The page's head element\r\n\t *\r\n\t * @returns Element\r\n\t * @memberof Page\r\n\t */\r\n    public getHead(): Element {\r\n        return this.head;\r\n    }\r\n\r\n\t/**\r\n\t * The page's body element\r\n\t *\r\n\t * @returns Element\r\n\t * @memberof Page\r\n\t */\r\n    public getBody(): Element {\r\n        return this.body;\r\n    }\r\n\r\n\t/**\r\n\t * The page's wrapper element\r\n\t *\r\n\t * @returns HTMLElement\r\n\t * @memberof Page\r\n\t */\r\n    public getWrapper(): HTMLElement {\r\n        return this.wrapper;\r\n    }\r\n\r\n\t/**\r\n\t * The page's document\r\n\t *\r\n\t * @returns Document\r\n\t * @memberof Page\r\n\t */\r\n    public getDOM(): Document {\r\n        return this.dom;\r\n    }\r\n}\r\n\r\n/**\r\n * Controls which page to be load\r\n *\r\n * @export\r\n * @class PageManager\r\n * @extends {AdvancedManager<string, Page>}\r\n */\r\nexport class PageManager extends AdvancedManager<string, Page> {\r\n    /**\r\n     * Stores all URLs that are currently loading\r\n     *\r\n     * @protected\r\n     * @type Manager<string, Promise<string>>\r\n     * @memberof PageManager\r\n     */\r\n    protected loading: Manager<string, Promise<string>> = new Manager();\r\n\r\n\t/**\r\n\t * Creates an instance of the PageManager\r\n\t *\r\n     * @param {App} app\r\n\t * @memberof PageManager\r\n\t */\r\n    constructor(app: App) {\r\n        super(app);\r\n        this.set(URLString, new Page());\r\n    }\r\n\r\n    /**\r\n     * Returns the loading Manager\r\n     *\r\n     * @returns Manager<string, Promise<string>>\r\n     * @memberof PageManager\r\n     */\r\n    public getLoading(): Manager<string, Promise<string>> {\r\n        return this.loading;\r\n    }\r\n\r\n    /**\r\n     * Load from cache or by requesting URL via a fetch request, avoid requesting for the same thing twice by storing the fetch request in \"this.loading\"\r\n     *\r\n     * @param {(_URL | string)} [_url=new _URL()]\r\n     * @returns Promise<Page>\r\n     * @memberof PageManager\r\n     */\r\n    public async load(_url: _URL | string = new _URL()): Promise<Page> {\r\n        let url: _URL = _url instanceof URL ? _url : new _URL(_url);\r\n        let urlString: string = url.getPathname();\r\n        let page: Page, request: Promise<string>;\r\n        if (this.has(urlString)) {\r\n            page = this.get(urlString);\r\n            return Promise.resolve(page);\r\n        }\r\n\r\n        if (!this.loading.has(urlString)) {\r\n            request = this.request(urlString);\r\n            this.loading.set(urlString, request);\r\n        } else request = this.loading.get(urlString);\r\n\r\n        let response = await request;\r\n        this.loading.delete(urlString);\r\n\r\n        page = new Page(url, response);\r\n        this.set(urlString, page);\r\n        return page;\r\n    }\r\n\r\n    /**\r\n     * Starts a fetch request\r\n     *\r\n     * @param {string} url\r\n     * @returns Promise<string>\r\n     * @memberof PageManager\r\n     */\r\n    public async request(url: string): Promise<string> {\r\n        const headers = new Headers(this.getConfig(\"headers\"));\r\n        const timeout = window.setTimeout(() => {\r\n            window.clearTimeout(timeout);\r\n            throw \"Request Timed Out!\";\r\n        }, this.getConfig(\"timeout\"));\r\n\r\n        try {\r\n            let response = await fetch(url, {\r\n                mode: 'same-origin',\r\n                method: \"GET\",\r\n                headers: headers,\r\n                cache: \"default\",\r\n                credentials: \"same-origin\",\r\n            });\r\n\r\n            window.clearTimeout(timeout);\r\n            if (response.status >= 200 && response.status < 300) {\r\n                return await response.text();\r\n            }\r\n\r\n            const err = new Error(response.statusText || \"\" + response.status);\r\n            throw err;\r\n        } catch (err) {\r\n            window.clearTimeout(timeout);\r\n            throw err;\r\n        }\r\n    }\r\n}","import { Manager } from \"managerjs/src/api\";\r\n\r\nexport type ListenerCallback = (...args: any) => void;\r\nexport interface IListener {\r\n    readonly callback: ListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Listener\r\n */\r\nexport class Listener {\r\n\t/**\r\n\t * The current listener data\r\n\t *\r\n\t * @private\r\n\t * @type IListener\r\n\t * @memberof Listener\r\n\t */\r\n    private listener: IListener;\r\n\r\n\t/**\r\n\t * Creates an instance of Listener.\r\n\t *\r\n\t * @param {IListener} { callback = () => { }, scope = null, name = \"event\" }\r\n\t * @memberof Listener\r\n\t */\r\n    constructor({\r\n        callback = () => { },\r\n        scope = null,\r\n        name = \"event\",\r\n    }: IListener) {\r\n        this.listener = { callback, scope, name };\r\n    }\r\n\r\n\t/**\r\n\t * Returns the callback Function of the Listener\r\n\t *\r\n\t * @returns ListenerCallback\r\n\t * @memberof Listener\r\n\t */\r\n    public getCallback(): ListenerCallback {\r\n        return this.listener.callback;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the scope as an Object, from the Listener\r\n\t *\r\n\t * @returns object\r\n\t * @memberof Listener\r\n\t */\r\n    public getScope(): object {\r\n        return this.listener.scope;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the event as a String, from the Listener\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Listener\r\n\t */\r\n    public getEventName(): string {\r\n        return this.listener.name;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the listener as an Object\r\n\t *\r\n\t * @returns IListener\r\n\t * @memberof Listener\r\n\t */\r\n    public toJSON(): IListener {\r\n        return this.listener;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Event\r\n * @extends {Manager<number, Listener>}\r\n */\r\nexport class Event extends Manager<number, Listener> {\r\n\t/**\r\n\t * The name of the event\r\n\t *\r\n\t * @private\r\n\t * @type string\r\n\t * @memberof Event\r\n\t */\r\n    private name: string;\r\n\r\n\t/**\r\n\t * Creates an instance of Event.\r\n\t *\r\n\t * @param {string} [name=\"event\"]\r\n\t * @memberof Event\r\n\t */\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport type EventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An event emitter\r\n *\r\n * @export\r\n * @class EventEmitter\r\n * @extends {Manager<string, Event>}\r\n */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n\t/**\r\n\t * Creates an instance of EventEmitter.\r\n\t *\r\n\t * @memberof EventEmitter\r\n\t */\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n\t * Gets events, if event doesn't exist create a new Event\r\n     *\r\n     * @param {string} name\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n\t/**\r\n\t * Creates a new listener and adds it to the event\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns Event\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public newListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(new Listener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n\t/**\r\n\t * Adds a listener for a given event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public on(\r\n        events: EventInput,\r\n        callback?: ListenerCallback,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let _scope: object;\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (typeof events == \"object\" && !Array.isArray(events)) {\r\n                _name = key;\r\n                _callback = events[key];\r\n                _scope = callback;\r\n            } else {\r\n                _name = events[key];\r\n                _callback = callback;\r\n                _scope = scope;\r\n            }\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Removes a listener from an event\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {ListenerCallback} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns Event\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public removeListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.getEvent(name);\r\n\r\n        if (callback) {\r\n            let i = 0,\r\n                len: number = event.size,\r\n                value: Listener;\r\n            let listener = new Listener({ name, callback, scope });\r\n            for (; i < len; i++) {\r\n                value = event.get(i);\r\n                console.log(value);\r\n                if (\r\n                    value.getCallback() === listener.getCallback() &&\r\n                    value.getScope() === listener.getScope()\r\n                )\r\n                    break;\r\n            }\r\n\r\n            event.delete(i);\r\n        }\r\n        return event;\r\n    }\r\n\r\n\t/**\r\n\t * Removes a listener from a given event, or it just completely removes an event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public off(\r\n        events: EventInput,\r\n        callback?: ListenerCallback,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let _scope: object;\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach((key) => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (typeof events == \"object\" && !Array.isArray(events)) {\r\n                _name = key;\r\n                _callback = events[key];\r\n                _scope = callback;\r\n            } else {\r\n                _name = events[key];\r\n                _callback = callback;\r\n                _scope = scope;\r\n            }\r\n\r\n            if (_callback) {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.delete(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Adds a one time event listener for an event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public once(\r\n        events: EventInput,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let onceFn: ListenerCallback = (...args) => {\r\n            this.off(events, onceFn, scope);\r\n            callback.apply(scope, args);\r\n        };\r\n\r\n        this.on(events, onceFn, scope);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Call all listeners within an event\r\n\t *\r\n\t * @param {(string | Array<any>)} events\r\n     * @param {...any} args\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let listeners: Event = this.getEvent(event);\r\n\r\n            const customEvent: CustomEvent<any> = new CustomEvent(event, { detail: args })\r\n            window.dispatchEvent(customEvent);\r\n\r\n            listeners.forEach((listener: Listener) => {\r\n                let { callback, scope }: IListener = listener.toJSON();\r\n                callback.apply(scope, args);\r\n            });\r\n        }, this);\r\n        return this;\r\n    }\r\n}","import { EventEmitter } from \"@okikio/event-emitter/src/api\";\r\nimport { AdvancedManager, ManagerItem } from \"./manager\";\r\nimport { TransitionManager } from \"./transition\";\r\nimport { HistoryManager } from \"./history\";\r\nimport { PageManager } from \"./page\";\r\nimport { App } from \"./app\";\r\n\r\n/**\r\n * Controls specific kinds of actions that require JS\r\n *\r\n * @export\r\n * @class Service\r\n */\r\nexport class Service extends ManagerItem {\r\n\t/**\r\n\t * Stores access to the App class's EventEmitter\r\n\t *\r\n\t * @protected\r\n\t * @type EventEmitter\r\n\t * @memberof Service\r\n\t */\r\n\tprotected EventEmitter: EventEmitter;\r\n\r\n\t/**\r\n\t * Stores access to the App class's PageManager\r\n\t *\r\n\t * @protected\r\n\t * @type PageManager\r\n\t * @memberof Service\r\n\t */\r\n\tprotected PageManager: PageManager;\r\n\r\n\t/**\r\n\t * Stores access to the App class's HistoryManager\r\n\t *\r\n\t * @protected\r\n\t * @type HistoryManager\r\n\t * @memberof Service\r\n\t */\r\n\tprotected HistoryManager: HistoryManager;\r\n\r\n\t/**\r\n\t * Stores the ServiceManager the service is install on\r\n\t *\r\n\t * @protected\r\n\t * @type ServiceManager\r\n\t * @memberof Service\r\n\t */\r\n\tprotected ServiceManager: ServiceManager;\r\n\r\n\t/**\r\n\t * Stores access to the App's TransitionManager\r\n\t *\r\n\t * @protected\r\n\t * @type TransitionManager\r\n\t * @memberof Service\r\n\t */\r\n\tprotected TransitionManager: TransitionManager;\r\n\r\n\t/**\r\n\t * Method is run once when Service is installed on a ServiceManager\r\n     *\r\n\t * @memberof Service\r\n\t */\r\n\tpublic install(): void {\r\n\t\tlet app = this.manager.getApp();\r\n\t\tthis.PageManager = app.getPages();\r\n\t\tthis.EventEmitter = app.getEmitter();\r\n\t\tthis.HistoryManager = app.getHistory();\r\n\t\tthis.ServiceManager = app.getServices();\r\n\t\tthis.TransitionManager = app.getTransitions();\r\n\t}\r\n\r\n\t// Called on start of Service\r\n\tpublic boot(): void { }\r\n\r\n\t// Initialize events\r\n\tpublic initEvents(): void { }\r\n\r\n\t// Stop events\r\n\tpublic stopEvents(): void { }\r\n\r\n\t// Stop services\r\n\tpublic stop(): void {\r\n\t\tthis.stopEvents();\r\n\t}\r\n}\r\n\r\n/**\r\n * The Service Manager controls the lifecycle of all services in an App\r\n *\r\n * @export\r\n * @class ServiceManager\r\n * @extends {AdvancedManager<number, Service>}\r\n */\r\nexport class ServiceManager extends AdvancedManager<number, Service> {\r\n    /**\r\n     * Creates an instance of ServiceManager.\r\n     *\r\n     * @param {App} app\r\n     * @memberof ServiceManager\r\n     */\r\n\tconstructor(app: App) {\r\n\t\tsuper(app);\r\n\t}\r\n\r\n\t/**\r\n\t * Call the boot method for all Services\r\n\t *\r\n\t * @returns Promise<void>\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic async boot(): Promise<void> {\r\n\t\tawait this.asyncMethodCall(\"boot\");\r\n\t}\r\n\r\n\t/**\r\n\t * Call the initEvents method for all Services\r\n\t *\r\n\t * @returns ServiceManager\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic initEvents(): ServiceManager {\r\n\t\tthis.methodCall(\"initEvents\");\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Call the stopEvents method for all Services\r\n\t *\r\n\t * @returns ServiceManager\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic stopEvents(): ServiceManager {\r\n\t\tthis.methodCall(\"stopEvents\");\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Call the stop method for all Services\r\n\t *\r\n\t * @returns ServiceManager\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic stop(): ServiceManager {\r\n\t\tthis.methodCall(\"stop\");\r\n\t\treturn this;\r\n\t}\r\n}","import { EventEmitter } from \"@okikio/event-emitter/src/api\";\r\nimport { AdvancedManager, ManagerItem } from \"./manager\";\r\nimport { Trigger } from \"./history\";\r\nimport { Page } from \"./page\";\r\nimport { App } from \"./app\";\r\n\r\n/**\r\n * The async function type, allows for smooth transition between Promises\r\n */\r\nexport type asyncFn = (err?: any, value?: any) => void;\r\nexport interface ITransition {\r\n    oldPage: Page,\r\n    newPage: Page,\r\n    trigger: Trigger\r\n}\r\nexport interface ITransitionData {\r\n    from?: Page,\r\n    to?: Page,\r\n    trigger?: Trigger,\r\n    done: asyncFn\r\n}\r\n\r\n/**\r\n * Controls the animation between pages\r\n *\r\n * @export\r\n * @class Transition\r\n */\r\nexport class Transition extends ManagerItem {\r\n\t/**\r\n\t * Transition name\r\n\t *\r\n\t * @protected\r\n\t * @type string\r\n\t * @memberof Transition\r\n\t */\r\n    protected name: string = \"Transition\";\r\n\r\n\t/**\r\n\t * The page to transition from\r\n\t *\r\n\t * @protected\r\n\t * @type Page\r\n\t * @memberof Transition\r\n\t */\r\n    protected oldPage: Page;\r\n\r\n\t/**\r\n\t * Page to transition to\r\n\t *\r\n\t * @protected\r\n\t * @type Page\r\n\t * @memberof Transition\r\n\t */\r\n    protected newPage: Page;\r\n\r\n\t/**\r\n\t * What triggered the transition to occur\r\n\t *\r\n\t * @protected\r\n\t * @type Trigger\r\n\t * @memberof Transition\r\n\t */\r\n    protected trigger: Trigger;\r\n\r\n    /**\r\n     * Creates an instance of Transition.\r\n     *\r\n     * @memberof Transition\r\n     */\r\n    constructor() { super(); }\r\n\r\n\t/**\r\n\t * Initialize the transition\r\n\t *\r\n\t * @param {ITransition} {\r\n\t * \t\toldPage,\r\n\t * \t\tnewPage,\r\n\t * \t\ttrigger\r\n\t * \t}\r\n     * @returns Transition\r\n\t * @memberof Transition\r\n\t */\r\n    public init({\r\n        oldPage,\r\n        newPage,\r\n        trigger\r\n    }: ITransition): Transition {\r\n        this.oldPage = oldPage;\r\n        this.newPage = newPage;\r\n        this.trigger = trigger;\r\n        this.boot();\r\n        return this;\r\n    }\r\n\r\n    // Called on start of Transition\r\n    public boot(): void { }\r\n\r\n    // Initialize events\r\n    public initEvents(): void { }\r\n\r\n    // Stop events\r\n    public stopEvents(): void { }\r\n\r\n    // Stop services\r\n    public stop(): void {\r\n        this.stopEvents();\r\n    }\r\n\r\n\t/**\r\n\t * Returns the Transition's name\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Transition\r\n\t */\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the Transition's old page\r\n\t *\r\n\t * @returns Page\r\n\t * @memberof Transition\r\n\t */\r\n    public getOldPage(): Page {\r\n        return this.oldPage;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the Transition's new page\r\n\t *\r\n\t * @returns Page\r\n\t * @memberof Transition\r\n\t */\r\n    public getNewPage(): Page {\r\n        return this.newPage;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the Transition's trigger\r\n\t *\r\n\t * @returns Trigger\r\n\t * @memberof Transition\r\n\t */\r\n    public getTrigger(): Trigger {\r\n        return this.trigger;\r\n    }\r\n\r\n    // Based off the highwayjs Transition class\r\n\t/**\r\n\t * Transition from current page\r\n\t *\r\n\t * @param {ITransitionData} { from, trigger, done }\r\n\t * @memberof Transition\r\n\t */\r\n    public out({ done }: ITransitionData): any {\r\n        done();\r\n    }\r\n\r\n\t/**\r\n\t * Transition into the next page\r\n\t *\r\n\t * @param {ITransitionData} { from, to, trigger, done }\r\n\t * @memberof Transition\r\n\t */\r\n    public in({ done }: ITransitionData): any {\r\n        done();\r\n    }\r\n\r\n    /**\r\n     * Starts the transition\r\n     *\r\n     * @returns Promise<Transition>\r\n     * @memberof Transition\r\n     */\r\n    public async start(EventEmitter: EventEmitter): Promise<Transition> {\r\n        let fromWrapper = this.oldPage.getWrapper();\r\n        let toWrapper = this.newPage.getWrapper();\r\n        document.title = this.newPage.getTitle();\r\n\r\n        return new Promise(async finish => {\r\n            EventEmitter.emit(\"BEFORE-TRANSITION-OUT\");\r\n            await new Promise(done => {\r\n                let outMethod: Promise<any> = this.out({\r\n                    from: this.oldPage,\r\n                    trigger: this.trigger,\r\n                    done\r\n                });\r\n\r\n                if (outMethod.then)\r\n                    outMethod.then(done);\r\n            });\r\n\r\n            EventEmitter.emit(\"AFTER-TRANSITION-OUT\");\r\n\r\n            await new Promise(done => {\r\n                fromWrapper.insertAdjacentElement('beforebegin', toWrapper);\r\n                fromWrapper.remove();\r\n                done();\r\n            });\r\n\r\n            EventEmitter.emit(\"BEFORE-TRANSITION-IN\");\r\n\r\n            await new Promise(done => {\r\n                let inMethod: Promise<any> = this.in({\r\n                    from: this.oldPage,\r\n                    to: this.newPage,\r\n                    trigger: this.trigger,\r\n                    done\r\n                });\r\n\r\n                if (inMethod.then)\r\n                    inMethod.then(done);\r\n            });\r\n\r\n            EventEmitter.emit(\"AFTER_TRANSITION_IN\");\r\n            finish();\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Controls which animation between pages to use\r\n *\r\n * @export\r\n * @class TransitionManager\r\n * @extends {AdvancedManager<string, Transition>}\r\n */\r\nexport class TransitionManager extends AdvancedManager<string, Transition> {\r\n\t/**\r\n\t * Creates an instance of the TransitionManager\r\n\t *\r\n     * @param {App} app\r\n\t * @memberof TransitionManager\r\n\t */\r\n    constructor(app: App) { super(app); }\r\n\r\n\t/**\r\n\t * Quick way to add a Transition to the TransitionManager\r\n\t *\r\n\t * @param {Transition} value\r\n\t * @returns TransitionManager\r\n\t * @memberof TransitionManager\r\n\t */\r\n    public add(value: Transition): TransitionManager {\r\n        let name = value.getName();\r\n        this.set(name, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Runs a transition\r\n     *\r\n     * @param {{ name: string, oldPage: Page, newPage: Page, trigger: Trigger }} { name, oldPage, newPage, trigger }\r\n     * @returns Promise<void>\r\n     * @memberof TransitionManager\r\n     */\r\n    public async boot({ name, oldPage, newPage, trigger }: { name: string, oldPage: Page, newPage: Page, trigger: Trigger }): Promise<Transition> {\r\n        let transition: Transition = this.get(name);\r\n        transition.init({\r\n            oldPage,\r\n            newPage,\r\n            trigger\r\n        });\r\n\r\n        let EventEmitter = this.getApp().getEmitter();\r\n        return await transition.start(EventEmitter);\r\n    }\r\n\r\n\t/**\r\n\t * Call the initEvents method for all Transitions\r\n\t *\r\n\t * @returns TransitionManager\r\n\t * @memberof TransitionManager\r\n\t */\r\n    public initEvents(): TransitionManager {\r\n        this.methodCall(\"initEvents\");\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Call the stopEvents method for all Transitions\r\n\t *\r\n\t * @returns TransitionManager\r\n\t * @memberof TransitionManager\r\n\t */\r\n    public stopEvents(): TransitionManager {\r\n        this.methodCall(\"stopEvents\");\r\n        return this;\r\n    }\r\n}","import { ManagerItem, AdvancedManager } from \"./manager\";\r\nimport { Service } from \"./service\";\r\nimport { App } from \"./app\";\r\n\r\n/**\r\n * Services that interact with specific Components to achieve certain actions\r\n *\r\n * @export\r\n * @class Block\r\n * @extends {Service}\r\n */\r\nexport class Block extends Service {\r\n    /**\r\n     * The name of the Block\r\n     *\r\n     * @protected\r\n     * @type string\r\n     * @memberof Block\r\n     */\r\n    protected name: string;\r\n\r\n    /**\r\n     * Query selector string \r\n     *\r\n     * @protected\r\n     * @type string\r\n     * @memberof Block\r\n     */\r\n    protected selector: string;\r\n\r\n    /**\r\n     * Index of Block in a BlockManager \r\n     *\r\n     * @protected\r\n     * @type number\r\n     * @memberof Block\r\n     */\r\n    protected index: number;\r\n\r\n    /**\r\n     * The Root Element of a Block\r\n     *\r\n     * @protected\r\n     * @type HTMLElement\r\n     * @memberof Block\r\n     */\r\n    protected rootElement: HTMLElement;\r\n\r\n    /**\r\n     * It initializes the Block\r\n     *\r\n     * @param {string} [name]\r\n     * @param {HTMLElement} [rootElement]\r\n     * @param {string} [selector]\r\n     * @param {number} [index]\r\n     * @memberof Block\r\n     */\r\n    public init(name?: string, rootElement?: HTMLElement, selector?: string, index?: number) {\r\n        this.rootElement = rootElement;\r\n        this.name = name;\r\n        this.selector = selector;\r\n        this.index = index;\r\n    }\r\n\r\n    /**\r\n     * Get Root Element\r\n     *\r\n     * @returns HTMLElement\r\n     * @memberof Block\r\n     */\r\n    public getRootElement(): HTMLElement {\r\n        return this.rootElement;\r\n    }\r\n\r\n    /**\r\n     * Get Selector\r\n     *\r\n     * @returns string\r\n     * @memberof Block\r\n     */\r\n    public getSelector(): string {\r\n        return this.selector;\r\n    }\r\n\r\n    /**\r\n     * Get Index\r\n     *\r\n     * @returns number\r\n     * @memberof Block\r\n     */\r\n    public getIndex(): number {\r\n        return this.index;\r\n    }\r\n\r\n    /**\r\n     * Get the name of the Block\r\n     *\r\n     * @returns string\r\n     * @memberof Block\r\n     */\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new Block Intent Class\r\n *\r\n * @export\r\n * @class BlockIntent\r\n * @extends {ManagerItem}\r\n */\r\nexport class BlockIntent extends ManagerItem {\r\n    /**\r\n     * The name of the Block\r\n     *\r\n     * @protected\r\n     * @type string\r\n     * @memberof BlockIntent\r\n     */\r\n    protected name: string;\r\n\r\n    /**\r\n     * The Block Class\r\n     *\r\n     * @protected\r\n     * @type {typeof Block}\r\n     * @memberof BlockIntent\r\n     */\r\n    protected block: typeof Block;\r\n\r\n    /**\r\n     * Creates an instance of BlockIntent.\r\n     *\r\n     * @param {string} name\r\n     * @param {typeof Block} block\r\n     * @memberof BlockIntent\r\n     */\r\n    constructor(name: string, block: typeof Block) {\r\n        super();\r\n        this.name = name;\r\n        this.block = block;\r\n    }\r\n\r\n    /**\r\n     * Getter for name of Block Intent\r\n     *\r\n     * @returns string\r\n     * @memberof BlockIntent\r\n     */\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Getter for the Block of the Block Intent\r\n     *\r\n     * @returns {typeof Block}\r\n     * @memberof BlockIntent\r\n     */\r\n    public getBlock(): typeof Block {\r\n        return this.block;\r\n    }\r\n}\r\n\r\n/**\r\n * A Service Manager designed to handle only Block Services, it refreshes on Page Change\r\n *\r\n * @export\r\n * @class BlockManager\r\n * @extends {AdvancedManager<number, BlockIntent>}\r\n */\r\nexport class BlockManager extends AdvancedManager<number, BlockIntent> {\r\n    /**\r\n     * A list of Active Blocks \r\n     *\r\n     * @protected\r\n     * @type {AdvancedManager<number, Block>}\r\n     * @memberof BlockManager\r\n     */\r\n    protected activeBlocks: AdvancedManager<number, Block>;\r\n\r\n    /**\r\n     * Creates an instance of BlockManager.\r\n     *\r\n     * @param {App} app\r\n     * @memberof BlockManager\r\n     */\r\n    constructor(app: App) {\r\n        super(app);\r\n        this.activeBlocks = new AdvancedManager(app);\r\n    }\r\n\r\n\t/**\r\n\t * Initialize all Blocks\r\n\t *\r\n\t * @memberof BlockManager\r\n\t */\r\n    public init() {\r\n        this.forEach((intent: BlockIntent) => {\r\n            let name: string = intent.getName();\r\n            let block: typeof Block = intent.getBlock();\r\n            let selector: string = `[${this.getConfig(\"blockAttr\", false)}=\"${name}\"]`;\r\n            let rootElements: Node[] = [...document.querySelectorAll(selector)];\r\n\r\n            for (let i = 0, len = rootElements.length; i < len; i++) {\r\n                let newInstance: Block = new block();\r\n                newInstance.init(name, rootElements[i] as HTMLElement, selector, i);\r\n                this.activeBlocks.set(i, newInstance);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Getter for activeBlocks in BlockManager\r\n     *\r\n     * @returns\r\n     * @memberof BlockManager\r\n     */\r\n    public getActiveBlocks() {\r\n        return this.activeBlocks;\r\n    }\r\n\r\n\t/**\r\n\t * Call the boot method for all Blocks\r\n\t *\r\n\t * @returns Promise<void>\r\n\t * @memberof BlockManager\r\n\t */\r\n    public async boot(): Promise<void> {\r\n        await this.activeBlocks.asyncMethodCall(\"boot\");\r\n    }\r\n\r\n    /**\r\n     * Refreshes DOM Elements\r\n     *\r\n     * @memberof BlockManager\r\n     */\r\n    public refresh() {\r\n        const EventEmitter = this.getApp().getEmitter();\r\n        EventEmitter.on(\"BEFORE_TRANSITION_OUT\", () => {\r\n            this.stop();\r\n        });\r\n\r\n        EventEmitter.on(\"AFTER_TRANSITION_IN\", () => {\r\n            this.init();\r\n            this.boot();\r\n            // this.activeBlocks.methodCall(\"initEvents\");\r\n        });\r\n    }\r\n\r\n\t/**\r\n\t * Call the initEvents method for all Blocks\r\n\t *\r\n\t * @returns BlockManager\r\n\t * @memberof BlockManager\r\n\t */\r\n    public initEvents(): BlockManager {\r\n        this.activeBlocks.methodCall(\"initEvents\");\r\n        this.refresh();\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Call the stopEvents method for all Blocks\r\n\t *\r\n\t * @returns BlockManager\r\n\t * @memberof BlockManager\r\n\t */\r\n    public stopEvents(): BlockManager {\r\n        this.activeBlocks.methodCall(\"stopEvents\");\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Call the stop method for all Blocks\r\n\t *\r\n\t * @returns BlockManager\r\n\t * @memberof BlockManager\r\n\t */\r\n    public stop(): BlockManager {\r\n        this.activeBlocks.methodCall(\"stop\");\r\n        this.activeBlocks.clear();\r\n        return this;\r\n    }\r\n}","import { EventEmitter, ListenerCallback, EventInput } from \"@okikio/event-emitter/src/api\";\r\nimport { TransitionManager, Transition } from \"./transition\";\r\nimport { BlockManager, BlockIntent, Block } from \"./block\";\r\nimport { HistoryManager, State, IState } from \"./history\";\r\nimport { ServiceManager, Service } from \"./service\";\r\nimport { PageManager, Page } from \"./page\";\r\nimport { CONFIG, ICONFIG } from \"./config\";\r\n\r\n/**\r\n * The App class starts the entire process, it controls all managers and all services\r\n *\r\n * @export\r\n * @class App\r\n */\r\nexport class App {\r\n    /**\r\n     * A new instance of the HistoryManager\r\n     *\r\n     * @protected\r\n     * @type HistoryManager\r\n     * @memberof App\r\n     */\r\n    protected history: HistoryManager;\r\n\r\n    /**\r\n     * A new instance of the TransitionManager\r\n     *\r\n     * @protected\r\n     * @type TransitionManager\r\n     * @memberof App\r\n     */\r\n    protected transitions: TransitionManager;\r\n\r\n    /**\r\n     * A new instance of the ServiceManager\r\n     *\r\n     * @protected\r\n     * @type ServiceManager\r\n     * @memberof App\r\n     */\r\n    protected services: ServiceManager;\r\n\r\n    /**\r\n     * A new instance of the BlockManager\r\n     *\r\n     * @protected\r\n     * @type BlockManager\r\n     * @memberof App\r\n     */\r\n    protected blocks: BlockManager;\r\n\r\n    /**\r\n     * A new instance of an EventEmitter\r\n     *\r\n     * @protected\r\n     * @type EventEmitter\r\n     * @memberof App\r\n     */\r\n    protected emitter: EventEmitter;\r\n\r\n    /**\r\n     * A new instance of the PageManager\r\n     *\r\n     * @protected\r\n     * @type PageManager\r\n     * @memberof App\r\n     */\r\n    protected pages: PageManager;\r\n\r\n    /**\r\n     * The current Configuration's for the framework\r\n     *\r\n     * @protected\r\n     * @type CONFIG\r\n     * @memberof App\r\n     */\r\n    protected config: CONFIG;\r\n\r\n    /**\r\n     * Creates an instance of App.\r\n     *\r\n     * @param {(ICONFIG | CONFIG)} [config={}]\r\n     * @memberof App\r\n     */\r\n    constructor(config: object = {}) {\r\n        this.register(config);\r\n    }\r\n\r\n    /**\r\n     * For registering all managers and the configurations\r\n     *\r\n     * @param {(ICONFIG | CONFIG)} [config={}]\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public register(config: ICONFIG | CONFIG = {}): App {\r\n        this.config = config instanceof CONFIG ? config : new CONFIG(config);\r\n        this.transitions = new TransitionManager(this);\r\n        this.services = new ServiceManager(this);\r\n        this.blocks = new BlockManager(this);\r\n        this.history = new HistoryManager();\r\n        this.pages = new PageManager(this);\r\n        this.emitter = new EventEmitter();\r\n\r\n        let handler = (() => {\r\n            document.removeEventListener(\"DOMContentLoaded\", handler);\r\n            window.removeEventListener(\"load\", handler);\r\n            this.emitter.emit(\"READY ready\");\r\n        }).bind(this);\r\n\r\n        document.addEventListener(\"DOMContentLoaded\", handler);\r\n        window.addEventListener(\"load\", handler);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the current configurations for the framework\r\n     *\r\n     * @param {...any} args\r\n     * @returns any\r\n     * @memberof App\r\n     */\r\n    public getConfig(...args: any): any {\r\n        return this.config.getConfig(...args);\r\n    }\r\n\r\n    /**\r\n     * Return the App's EventEmitter\r\n     *\r\n     * @returns EventEmitter\r\n     * @memberof App\r\n     */\r\n    public getEmitter(): EventEmitter {\r\n        return this.emitter;\r\n    }\r\n\r\n    /**\r\n     * Returns the App's BlockManager\r\n     *\r\n     * @returns BlockManager\r\n     * @memberof App\r\n     */\r\n    public getBlocks(): BlockManager {\r\n        return this.blocks;\r\n    }\r\n\r\n    /**\r\n     * Return the App's ServiceManager\r\n     *\r\n     * @returns ServiceManager\r\n     * @memberof App\r\n     */\r\n    public getServices(): ServiceManager {\r\n        return this.services;\r\n    }\r\n\r\n    /**\r\n     * Return the App's PageManager\r\n     *\r\n     * @returns PageManager\r\n     * @memberof App\r\n     */\r\n    public getPages(): PageManager {\r\n        return this.pages;\r\n    }\r\n\r\n    /**\r\n     * Return the App's TransitionManager\r\n     *\r\n     * @returns TransitionManager\r\n     * @memberof App\r\n     */\r\n    public getTransitions(): TransitionManager {\r\n        return this.transitions;\r\n    }\r\n\r\n    /**\r\n     * Return the App's HistoryManager\r\n     *\r\n     * @returns HistoryManager\r\n     * @memberof App\r\n     */\r\n    public getHistory(): HistoryManager {\r\n        return this.history;\r\n    }\r\n\r\n    /**\r\n     * Returns a Block Intent Object from the App's instance of the BlockManager\r\n     *\r\n     * @param {number} key\r\n     * @returns IBlockIntent\r\n     * @memberof App\r\n     */\r\n    public getBlock(key: number): BlockIntent {\r\n        return this.blocks.get(key);\r\n    }\r\n\r\n    /**\r\n     * Returns an instance of a Block from the App's instance of the BlockManager\r\n     *\r\n     * @param {number} key\r\n     * @returns Block\r\n     * @memberof App\r\n     */\r\n    public getActiveBlock(key: number): Block {\r\n        return this.blocks.getActiveBlocks().get(key);\r\n    }\r\n\r\n    /**\r\n     * Returns a Service from the App's instance of the ServiceManager\r\n     *\r\n     * @param {number} key\r\n     * @returns Service\r\n     * @memberof App\r\n     */\r\n    public getService(key: number): Service {\r\n        return this.services.get(key);\r\n    }\r\n\r\n    /**\r\n     * Returns a Transition from the App's instance of the TransitionManager\r\n     *\r\n     * @param {string} key\r\n     * @returns Transition\r\n     * @memberof App\r\n     */\r\n    public getTransition(key: string): Transition {\r\n        return this.transitions.get(key);\r\n    }\r\n\r\n    /**\r\n     * Returns a State from the App's instance of the HistoryManager\r\n     *\r\n     * @param {number} key\r\n     * @returns State\r\n     * @memberof App\r\n     */\r\n    public getState(key: number): State {\r\n        return this.history.get(key);\r\n    }\r\n\r\n    /**\r\n     * Based on the type, it will return either a Transition, a Service, or a State from their respective Managers\r\n     *\r\n     * @param {(\"service\" | \"transition\" | \"state\" | \"block\" | string)} type\r\n     * @param {any} key\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public get(type: \"service\" | \"transition\" | \"state\" | \"block\" | string, key: any): App {\r\n        switch (type.toLowerCase()) {\r\n            case \"service\":\r\n                this.getService(key);\r\n                break;\r\n            case \"transition\":\r\n                this.getTransition(key);\r\n                break;\r\n            case \"state\":\r\n                this.getState(key);\r\n                break;\r\n            case \"block\":\r\n                this.getActiveBlock(key);\r\n                break;\r\n            default:\r\n                throw `Error: can't get type '${type}', it is not a recognized type. Did you spell it correctly.`;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a Page\r\n     *\r\n     * @param {string} url\r\n     * @returns Promise<Page>\r\n     * @memberof App\r\n     */\r\n    public async loadPage(url: string): Promise<Page> {\r\n        return await this.pages.load(url);\r\n    }\r\n\r\n    /**\r\n     * Based on the type, it will return load a Transition, a Service, a State, or a Page from their respective Managers\r\n     *\r\n     * @param {(\"page\" | string)} type\r\n     * @param {any} key\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public async load(type: \"page\" | string, key: any): Promise<any> {\r\n        switch (type.toLowerCase()) {\r\n            case \"page\":\r\n                return await this.loadPage(key);\r\n            default:\r\n                return Promise.resolve(this.get(type, key));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a Block Intent to the App's instance of the BlockManager\r\n     *\r\n     * @param {BlockIntent} blockIntent\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public addBlock(blockIntent: BlockIntent): App {\r\n        this.blocks.add(blockIntent);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a Service to the App's instance of the ServiceManager\r\n     *\r\n     * @param {Service} service\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public addService(service: Service): App {\r\n        this.services.add(service);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a Transition to the App's instance of the TransitionManager\r\n     *\r\n     * @param {Transition} transition\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public addTransition(transition: Transition): App {\r\n        this.transitions.add(transition);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a State to the App's instance of the HistoryManager\r\n     *\r\n     * @param {(IState | State)} state\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public addState(state: IState | State): App {\r\n        this.history.addState(state);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Based on the type, it will add either a Transition, a Service, or a State to their respective Managers\r\n     *\r\n     * @param {(\"service\" | \"transition\" | \"state\")} type\r\n     * @param {any} value\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public add(type: \"service\" | \"transition\" | \"state\" | \"block\", value: any): App {\r\n        switch (type.toLowerCase()) {\r\n            case \"service\":\r\n                this.addService(value);\r\n                break;\r\n            case \"transition\":\r\n                this.addTransition(value);\r\n                break;\r\n            case \"state\":\r\n                this.addState(value);\r\n                break;\r\n            case \"block\":\r\n                this.addBlock(value);\r\n                break;\r\n            default:\r\n                throw `Error: can't add type '${type}', it is not a recognized type. Did you spell it correctly.`;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Start the App and the ServiceManager\r\n     *\r\n     * @returns Promise<App>\r\n     * @memberof App\r\n     */\r\n    public async boot(): Promise<App> {\r\n        this.blocks.init();\r\n        await this.services.boot();\r\n        await this.blocks.boot();\r\n        this.services.initEvents();\r\n        this.blocks.initEvents();\r\n        this.transitions.initEvents();\r\n        return Promise.resolve(this);\r\n    }\r\n\r\n    /**\r\n     * Stop the App and the ServiceManager\r\n     *\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public stop(): App {\r\n        this.services.stop();\r\n        this.blocks.stop();\r\n        this.transitions.stopEvents();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the current page in the PageManager\r\n     *\r\n     * @returns Page\r\n     * @memberof App\r\n     */\r\n    public currentPage(): Page {\r\n        let currentState = this.history.last();\r\n        return this.pages.get(currentState.getURLPathname());\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter on method\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback} callback\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public on(events: EventInput, callback?: ListenerCallback): App {\r\n        this.emitter.on(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter off method\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback} callback\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public off(events: EventInput, callback?: ListenerCallback): App {\r\n        this.emitter.off(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter once method\r\n     *\r\n     * @param {string} events\r\n     * @param {ListenerCallback} callback\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public once(events: string, callback: ListenerCallback): App {\r\n        this.emitter.once(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter emit method\r\n     *\r\n     * @param {(string | any[])} events\r\n     * @param {...any} args\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public emit(events: string | any[], ...args: any): App {\r\n        this.emitter.emit(events, ...args);\r\n        return this;\r\n    }\r\n}\r\n","import { State, Trigger, IState, Coords } from \"./history\";\r\nimport { Service } from \"./service\";\r\nimport { Page } from \"./page\";\r\nimport { _URL } from \"./url\";\r\n\r\nexport type LinkEvent = MouseEvent | TouchEvent;\r\nexport type StateEvent = LinkEvent | PopStateEvent;\r\nexport type IgnoreURLsList = Array<RegExp | string>;\r\n\r\n/**\r\n * Creates a Barba JS like PJAX Service, for the Framework\r\n *\r\n * @export\r\n * @class PJAX\r\n * @extends {Service}\r\n */\r\n// Based on Barba JS and StartingBlocks\r\nexport class PJAX extends Service {\r\n    /**\r\n     * URLs to ignore when prefetching\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected ignoreURLs: IgnoreURLsList = [];\r\n\r\n    /**\r\n     * Whether or not to disable prefetching\r\n     *\r\n     * @private\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    protected prefetchIgnore: boolean = false;\r\n\r\n    /**\r\n     * Current state or transitions\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected isTransitioning: boolean = false;\r\n\r\n    /**\r\n     * Ignore extra clicks of an anchor element if a transition has already started\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected stopOnTransitioning: boolean = false;\r\n\r\n    /**\r\n     * On page change (excluding popstate event) keep current scroll position\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected stickyScroll: boolean = true;\r\n\r\n    /**\r\n     * Force load a page if an error occurs\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected forceOnError: boolean = false;\r\n\r\n    /**\r\n     * Dictates whether to auto scroll if an hash is present in the window URL\r\n     *\r\n     * @protected\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected autoScrollOnHash: boolean = true;\r\n\r\n    /**\r\n     * Sets the transition state, sets isTransitioning to true\r\n     *\r\n     * @private\r\n     * @memberof PJAX\r\n     */\r\n    private transitionStart() {\r\n        this.isTransitioning = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the transition state, sets isTransitioning to false\r\n     *\r\n     * @private\r\n     * @memberof PJAX\r\n     */\r\n    private transitionStop() {\r\n        this.isTransitioning = false;\r\n    }\r\n\r\n    /**\r\n     * Starts the PJAX Service\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public boot() {\r\n        let current = new State();\r\n        this.HistoryManager.add(current);\r\n        this.changeState(\"replace\", current);\r\n    }\r\n\r\n    /**\r\n     * Gets the transition to use for a certain anchor\r\n     *\r\n     * @param {HTMLAnchorElement} el\r\n     * @returns {(string | null)}\r\n     * @memberof PJAX\r\n     */\r\n    public getTransitionName(el: HTMLAnchorElement): string | null {\r\n        if (!el || !el.getAttribute) return null;\r\n        let transitionAttr = el.getAttribute(this.getConfig(\"transitionAttr\", false));\r\n        if (typeof transitionAttr === 'string')\r\n            return transitionAttr;\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the anchor is valid\r\n     *\r\n     * @param {HTMLAnchorElement} el\r\n     * @param {(LinkEvent | KeyboardEvent)} event\r\n     * @param {string} href\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public validLink(el: HTMLAnchorElement, event: LinkEvent | KeyboardEvent, href: string): boolean {\r\n        let pushStateSupport = !window.history.pushState;\r\n        let exists = !el || !href;\r\n        let eventMutate =\r\n            (event as KeyboardEvent).which > 1 ||\r\n            (event as KeyboardEvent).metaKey ||\r\n            (event as KeyboardEvent).ctrlKey ||\r\n            (event as KeyboardEvent).shiftKey ||\r\n            (event as KeyboardEvent).altKey;\r\n        let newTab = el.hasAttribute('target') && (el as HTMLAnchorElement).target === '_blank';\r\n        let crossOrigin =\r\n            ((el as HTMLAnchorElement).protocol !== location.protocol) ||\r\n            ((el as HTMLAnchorElement).hostname !== location.hostname);\r\n        let download = typeof el.getAttribute('download') === 'string';\r\n        let preventSelf = el.hasAttribute(this.getConfig(\"preventSelfAttr\", false));\r\n        let preventAll = Boolean(\r\n            el.closest(this.getConfig(\"preventAllAttr\"))\r\n        );\r\n        let prevent = preventSelf && preventAll;\r\n        let sameURL = new _URL().getFullPath() === new _URL(href).getFullPath();\r\n        return !(exists || pushStateSupport || eventMutate || newTab || crossOrigin || download || prevent || sameURL);\r\n    }\r\n\r\n    /**\r\n     * Returns the href or an Anchor element\r\n     *\r\n     * @param {HTMLAnchorElement} el\r\n     * @returns {(string | null)}\r\n     * @memberof PJAX\r\n     */\r\n    public getHref(el: HTMLAnchorElement): string | null {\r\n        if (el && el.tagName && el.tagName.toLowerCase() === 'a' && typeof el.href === 'string')\r\n            return el.href;\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if event target is a valid anchor with an href, if so, return the link\r\n     *\r\n     * @param {LinkEvent} event\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public getLink(event: LinkEvent): HTMLAnchorElement {\r\n        let el = event.target as HTMLAnchorElement;\r\n        let href: string = this.getHref(el);\r\n\r\n        while (el && !href) {\r\n            el = (el as HTMLElement).parentNode as HTMLAnchorElement;\r\n            href = this.getHref(el);\r\n        }\r\n\r\n        // Check for a valid link\r\n        if (!el || !this.validLink(el, event, href)) return;\r\n        return el;\r\n    }\r\n\r\n    /**\r\n     * When an element is clicked.\r\n     *\r\n     * Get valid anchor element.\r\n     * Go for a transition.\r\n     *\r\n     * @param {LinkEvent} event\r\n     * @returns\r\n     * @memberof PJAX\r\n     */\r\n    public onClick(event: LinkEvent) {\r\n        let el = this.getLink(event);\r\n        if (!el) return;\r\n\r\n        if (this.isTransitioning && this.stopOnTransitioning) {\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n            return;\r\n        }\r\n\r\n        let href = this.getHref(el);\r\n        this.EventEmitter.emit(\"ANCHOR-CLICK CLICK click\", event);\r\n        this.go({ href, trigger: el, event });\r\n    }\r\n\r\n    /**\r\n     * Returns the direction of the State change as a String, either the Back button or the Forward button\r\n     *\r\n     * @param {number} value\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public getDirection(value: number): Trigger {\r\n        if (Math.abs(value) > 1) {\r\n            // Ex 6-0 > 0 -> forward, 0-6 < 0 -> back\r\n            return value > 0 ? 'forward' : 'back';\r\n        } else {\r\n            if (value === 0) {\r\n                return 'popstate';\r\n            } else {\r\n                // Ex 6-5 > 0 -> back, 5-6 < 0 -> forward\r\n                return value > 0 ? 'back' : 'forward';\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force a page to go to a certain URL\r\n     *\r\n     * @param {string} href\r\n     * @memberof PJAX\r\n     */\r\n    public force(href: string): void {\r\n        window.location.assign(href);\r\n    }\r\n\r\n    /**\r\n     * If transition is running force load page.\r\n     * Stop if currentURL is the same as new url.\r\n     * On state change, change the current state history,\r\n     * to reflect the direction of said state change\r\n     * Load page and page transition.\r\n     *\r\n     * @param {string} href\r\n     * @param {Trigger} [trigger='HistoryManager']\r\n     * @param {StateEvent} [event]\r\n     * @memberof PJAX\r\n     */\r\n    public go({ href, trigger = 'HistoryManager', event }: { href: string; trigger?: Trigger; event?: StateEvent; }): Promise<void> {\r\n        // If transition is already running and the go method is called again, force load page\r\n        if (this.isTransitioning && this.stopOnTransitioning) {\r\n            this.force(href);\r\n            return;\r\n        }\r\n\r\n        let url = new _URL(href);\r\n        let currentState = this.HistoryManager.last();\r\n        let currentURL = currentState.getURL();\r\n        if (currentURL.equalTo(url)) {\r\n            this.hashAction(url.hash);\r\n            return;\r\n        }\r\n\r\n        let transitionName: string;\r\n        if (event && (event as PopStateEvent).state) {\r\n            this.EventEmitter.emit(\"POPSTATE\", event);\r\n\r\n            // If popstate, get back/forward direction.\r\n            let { state }: { state: IState } = event as PopStateEvent;\r\n            let { index, transition, data } = state;\r\n            let currentIndex = currentState.getIndex();\r\n            let difference = currentIndex - index;\r\n\r\n            trigger = this.getDirection(difference);\r\n            transitionName = transition;\r\n\r\n            // If page remains the same on state change DO NOT run this, it's pointless\r\n            if (trigger !== \"popstate\") {\r\n                // Keep scroll position\r\n                let { x, y } = data.scroll;\r\n                window.scroll({\r\n                    top: y, left: x,\r\n                    behavior: 'smooth'  //  \r\n                });\r\n            }\r\n\r\n            // Based on the direction of the state change either remove or add a state\r\n            if (trigger === \"back\") {\r\n                this.HistoryManager.delete(currentIndex);\r\n                this.EventEmitter.emit(`POPSTATE-BACK`, event);\r\n            } else if (trigger === \"forward\") {\r\n                this.HistoryManager.addState({ url, transition, data });\r\n                this.EventEmitter.emit(`POPSTATE-FORWARD`, event);\r\n            }\r\n        } else {\r\n            // Add new state\r\n            transitionName = this.getTransitionName(trigger as HTMLAnchorElement) || \"default\";\r\n            const scroll = new Coords();\r\n            const index = this.HistoryManager.size;\r\n            const state = new State({\r\n                url, index,\r\n                transition: transitionName,\r\n                data: { scroll }\r\n            });\r\n\r\n            if (this.stickyScroll) {\r\n                // Keep scroll position\r\n                let { x, y } = scroll;\r\n                window.scroll({\r\n                    top: y, left: x,\r\n                    behavior: 'smooth'  //  \r\n                });\r\n            } else {\r\n                window.scroll({\r\n                    top: 0, left: 0,\r\n                    behavior: 'smooth'  //  \r\n                });\r\n            }\r\n\r\n            this.HistoryManager.add(state);\r\n            this.changeState(\"push\", state);\r\n            this.EventEmitter.emit(\"HISTORY-NEW-ITEM\", event);\r\n        }\r\n\r\n        if (event) {\r\n            event.stopPropagation();\r\n            event.preventDefault();\r\n        }\r\n\r\n        this.EventEmitter.emit(\"GO go\", event);\r\n        return this.load({ oldHref: currentURL.getPathname(), href, trigger, transitionName });\r\n    }\r\n\r\n    /**\r\n     * Either push or replace history state\r\n     *\r\n     * @param {(\"push\" | \"replace\")} action\r\n     * @param {IState} state\r\n     * @param {_URL} url\r\n     * @memberof PJAX\r\n     */\r\n    public changeState(action: \"push\" | \"replace\", state: State) {\r\n        let url = state.getURL();\r\n        let href = url.getFullPath();\r\n        let json = state.toJSON();\r\n        let args = [json, '', href];\r\n        if (window.history) {\r\n            switch (action) {\r\n                case 'push':\r\n                    window.history.pushState.apply(window.history, args);\r\n                    break;\r\n                case 'replace':\r\n                    window.history.replaceState.apply(window.history, args);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the new Page as well as a Transition; run the Transition\r\n     *\r\n     * @param {string} oldHref\r\n     * @param {string} href\r\n     * @param {Trigger} trigger\r\n     * @param {string} [transitionName=\"default\"]\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public async load({ oldHref, href, trigger, transitionName = \"default\" }: { oldHref: string; href: string; trigger: Trigger; transitionName?: string; }): Promise<any> {\r\n        try {\r\n            let oldPage = this.PageManager.get(oldHref);\r\n            let newPage: Page;\r\n\r\n            this.EventEmitter.emit(\"PAGE-LOADING\", { href, oldPage, trigger });\r\n            try {\r\n                try {\r\n                    newPage = await this.PageManager.load(href);\r\n                    this.transitionStart();\r\n                    this.EventEmitter.emit(\"PAGE-LOAD-COMPLETE\", { newPage, oldPage, trigger });\r\n                } catch (err) {\r\n                    throw `[PJAX] Page load error: ${err}`;\r\n                }\r\n\r\n                // --\r\n                // --\r\n\r\n                this.EventEmitter.emit(\"NAVIGATION-START\", { oldPage, newPage, trigger, transitionName });\r\n                try {\r\n                    this.EventEmitter.emit(\"TRANSITION-START\", transitionName);\r\n                    let transition = await this.TransitionManager.boot({\r\n                        name: transitionName,\r\n                        oldPage,\r\n                        newPage,\r\n                        trigger\r\n                    });\r\n\r\n                    this.EventEmitter.emit(\"TRANSITION-END\", { transition });\r\n                } catch (err) {\r\n                    throw `[PJAX] Transition error: ${err}`;\r\n                }\r\n\r\n                this.EventEmitter.emit(\"NAVIGATION-END\", { oldPage, newPage, trigger, transitionName });\r\n                this.hashAction();\r\n            } catch (err) {\r\n                this.transitionStop();\r\n                throw err;\r\n            }\r\n\r\n            this.transitionStop(); // Sets isTransitioning to false\r\n        } catch (err) {\r\n            if (this.forceOnError) this.force(href);\r\n            else console.error(err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Auto scrolls to an elements position if the element has an hash\r\n     *\r\n     * @param {string} [hash=window.location.hash]\r\n     * @memberof PJAX\r\n     */\r\n    public hashAction(hash: string = window.location.hash) {\r\n        if (this.autoScrollOnHash) {\r\n            let hashID = hash.slice(1);\r\n\r\n            if (hashID.length) {\r\n                let el = document.getElementById(hashID);\r\n\r\n                if (el) {\r\n                    if (el.scrollIntoView) {\r\n                        el.scrollIntoView({ behavior: 'smooth' });\r\n                    } else {\r\n                        let { left, top } = el.getBoundingClientRect();\r\n                        window.scroll({ left, top, behavior: 'smooth' });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check to see if the URL is to be ignored, uses either RegExp of Strings to check\r\n     *\r\n     * @param {_URL} { pathname }\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public ignoredURL({ pathname }: _URL): boolean {\r\n        return this.ignoreURLs.length && this.ignoreURLs.some(url => {\r\n            return typeof url === \"string\" ? url === pathname : (url as RegExp).exec(pathname) !== null;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * When you hover over an anchor, prefetch the event target's href\r\n     *\r\n     * @param {LinkEvent} event\r\n     * @memberof PJAX\r\n     */\r\n    public onHover(event: LinkEvent): Promise<void> {\r\n        let el = this.getLink(event);\r\n        if (!el) return;\r\n\r\n        const url = new _URL(this.getHref(el));\r\n        const urlString: string = url.getPathname();\r\n        // If Url is ignored or already in cache, don't do any think\r\n        if (this.ignoredURL(url) || this.PageManager.has(urlString)) return;\r\n\r\n        this.EventEmitter.emit(\"ANCHOR-HOVER HOVER hover\", event);\r\n\r\n        (async () => {\r\n            try {\r\n                await this.PageManager.load(url);\r\n            } catch (err) {\r\n                console.warn(\"[PJAX] Prefetch error: \", err);\r\n            }\r\n        })();\r\n    }\r\n\r\n    /**\r\n     * When History state changes.\r\n     *\r\n     * Get url from State\r\n     * Go for a Barba transition.\r\n     *\r\n     * @param {PopStateEvent} event\r\n     * @memberof PJAX\r\n     */\r\n    public onStateChange(event: PopStateEvent): void {\r\n        this.go({ href: window.location.href, trigger: 'popstate', event });\r\n    }\r\n\r\n    /**\r\n     * Bind the event listeners to the PJAX class\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public bindEvents() {\r\n        this.onHover = this.onHover.bind(this);\r\n        this.onClick = this.onClick.bind(this);\r\n        this.onStateChange = this.onStateChange.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Initialize DOM Events\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public initEvents() {\r\n        this.bindEvents();\r\n\r\n        if (this.prefetchIgnore !== true) {\r\n            document.addEventListener('mouseover', this.onHover);\r\n            document.addEventListener('touchstart', this.onHover);\r\n        }\r\n\r\n        document.addEventListener('click', this.onClick);\r\n        window.addEventListener('popstate', this.onStateChange);\r\n    }\r\n\r\n    /**\r\n     * Stop DOM Events\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public stopEvents() {\r\n        if (this.prefetchIgnore !== true) {\r\n            document.removeEventListener('mouseover', this.onHover);\r\n            document.removeEventListener('touchstart', this.onHover);\r\n        }\r\n\r\n        document.removeEventListener('click', this.onClick);\r\n        window.removeEventListener('popstate', this.onStateChange);\r\n    }\r\n}"],"names":["CONFIG_DEFAULTS","wrapperAttr","noAjaxLinkAttr","noPrefetchAttr","headers","preventSelfAttr","preventAllAttr","transitionAttr","blockAttr","timeout","CONFIG","config","this","Object","assign","toAttr","value","brackets","prefix","attr","getConfig","Manager","[object Object]","map","Map","key","get","keys","values","set","size","distance","last","delete","clear","has","entries","callback","args","context","forEach","Symbol","iterator","method","item","ManagerItem","manager","install","register","AdvancedManager","app","_this","_Manager","getApp","_URL","url","window","location","href","URL","origin","getFullPath","pathname","hash","getHash","slice","clean","toString","replace","getPathname","equalTo","equal","a","b","urlA","urlB","newURL","URLString","Coords","x","y","scrollX","scrollY","State","state","index","transition","data","scroll","trigger","getIndex","setIndex","getURL","getURLPathname","getTransition","getData","toJSON","HistoryManager","add","addState","PARSER","DOMParser","Page","dom","document","parseFromString","head","body","title","wrapper","querySelector","getTitle","getHead","getBody","getWrapper","getDOM","PageManager","_this2","getLoading","loading","load","_url","page","request","urlString","_this4","Promise","resolve","response","Headers","setTimeout","clearTimeout","fetch","mode","cache","credentials","Error","statusText","status","text","err","Listener","scope","name","listener","Event","super","EventEmitter","event","getEvent","events","_name","_callback","_scope","split","Array","isArray","newListener","i","len","console","log","getCallback","getScope","removeListener","onceFn","off","apply","on","listeners","customEvent","CustomEvent","detail","dispatchEvent","Service","getPages","getEmitter","getHistory","ServiceManager","getServices","TransitionManager","getTransitions","boot","initEvents","stopEvents","stop","asyncMethodCall","methodCall","Transition","init","newPage","oldPage","getName","getOldPage","getNewPage","getTrigger","out","done","start","fromWrapper","_this3","toWrapper","finish","emit","outMethod","from","then","insertAdjacentElement","remove","inMethod","to","Block","rootElement","selector","getRootElement","getSelector","BlockIntent","block","getBlock","BlockManager","activeBlocks","intent","rootElements","querySelectorAll","length","newInstance","getActiveBlocks","refresh","_this6","App","transitions","services","blocks","history","pages","emitter","handler","removeEventListener","bind","addEventListener","getBlocks","getActiveBlock","getService","getState","type","toLowerCase","loadPage","addBlock","blockIntent","addService","service","addTransition","_this7","currentPage","currentState","once","PJAX","transitionStart","isTransitioning","transitionStop","current","changeState","getTransitionName","el","getAttribute","validLink","pushStateSupport","pushState","exists","eventMutate","which","metaKey","ctrlKey","shiftKey","altKey","newTab","hasAttribute","target","crossOrigin","protocol","hostname","download","preventSelf","preventAll","Boolean","closest","prevent","sameURL","getHref","tagName","getLink","parentNode","onClick","stopOnTransitioning","preventDefault","stopPropagation","go","getDirection","Math","abs","force","currentURL","transitionName","currentIndex","top","left","behavior","stickyScroll","oldHref","hashAction","action","replaceState","forceOnError","error","autoScrollOnHash","hashID","getElementById","scrollIntoView","getBoundingClientRect","ignoredURL","ignoreURLs","some","exec","onHover","warn","onStateChange","bindEvents","prefetchIgnore"],"mappings":"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"}