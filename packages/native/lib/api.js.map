{"version":3,"file":"api.js","sources":["../src/config.ts","../../manager/src/api.ts","../src/manager.ts","../src/url.ts","../src/history.ts","../src/page.ts","../../emitter/src/api.ts","../src/service.ts","../src/transition.ts","../src/block.ts","../src/app.ts","../src/pjax.ts","../src/route.ts"],"sourcesContent":["// The config variables\r\nexport interface ICONFIG {\r\n    prefix?: string;\r\n    wrapperAttr?: string;\r\n    noAjaxLinkAttr?: string;\r\n    noPrefetchAttr?: \"no-prefetch\";\r\n    headers?: string[][];\r\n    preventSelfAttr?: string;\r\n    preventAllAttr?: string;\r\n    transitionAttr?: string;\r\n    blockAttr?: string;\r\n    timeout?: number\r\n}\r\n\r\nexport const CONFIG_DEFAULTS: ICONFIG = {\r\n    wrapperAttr: \"wrapper\",\r\n    noAjaxLinkAttr: \"no-ajax-link\",\r\n    noPrefetchAttr: \"no-prefetch\",\r\n    headers: [\r\n        [\"x-partial\", \"true\"]\r\n    ],\r\n    preventSelfAttr: `prevent=\"self\"`,\r\n    preventAllAttr: `prevent=\"all\"`,\r\n    transitionAttr: \"transition\",\r\n    blockAttr: `block`,\r\n    timeout: 30000\r\n};\r\n\r\nexport type ConfigKeys = keyof ICONFIG;\r\n\r\n/**\r\n * The Config class\r\n *\r\n * @export\r\n * @class CONFIG\r\n */\r\nexport class CONFIG {\r\n    /**\r\n     * The current Configuration\r\n     *\r\n     * @protected\r\n     * @type ICONFIG\r\n     * @memberof CONFIG\r\n     */\r\n    protected config: ICONFIG;\r\n\r\n    /**\r\n     * Creates an instance of CONFIG.\r\n     *\r\n     * @param {ICONFIG} config\r\n     * @memberof CONFIG\r\n     */\r\n    constructor(config: ICONFIG) {\r\n        this.config = Object.assign({ ...CONFIG_DEFAULTS }, config);\r\n    }\r\n\r\n    /**\r\n     * Converts string into data attributes\r\n     *\r\n     * @param {string} value\r\n     * @param {boolean} brackets [brackets=true]\r\n     * @returns string\r\n     * @memberof CONFIG\r\n     */\r\n    public toAttr(value: string, brackets: boolean = true): string {\r\n        let { prefix } = this.config;\r\n        let attr = `data${prefix ? \"-\" + prefix : \"\"}-${value}`;\r\n        return brackets ? `[${attr}]` : attr;\r\n    }\r\n\r\n    /**\r\n     * Selects config vars, and formats them for use, or simply returns the current configurations for the framework\r\n     *\r\n     * @param {ConfigKeys} value\r\n     * @param {boolean} [brackets=true]\r\n     * @returns any\r\n     * @memberof CONFIG\r\n     */\r\n    public getConfig(value?: ConfigKeys, brackets: boolean = true): any {\r\n        if (typeof value !== \"string\")\r\n            return this.config;\r\n\r\n        let config = this.config[value];\r\n        if (typeof config === \"string\")\r\n            return this.toAttr(config, brackets);\r\n        return config;\r\n    }\r\n}","\r\n/**\r\n * Manages complex lists of named data, eg. A page can be stored in a list by of other pages with the url being how the page is stored in the list. Managers use Maps to store data.\r\n *\r\n * @export\r\n * @class Manager\r\n * @template K\r\n * @template V\r\n */\r\nexport class Manager<K, V> {\r\n\t/**\r\n\t * The complex list of named data, to which the Manager controls\r\n\t *\r\n\t * @protected\r\n\t * @type Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tprotected map: Map<K, V>;\r\n\r\n    /**\r\n     * Creates an instance of Manager.\r\n     * \r\n     * @param {Array<[K, V]>} [value]\r\n     * @memberof Manager\r\n     */\r\n\tconstructor(value?: Array<[K, V]>) {\r\n\t\tthis.map = new Map(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Manager class's list\r\n\t *\r\n\t * @returns Map<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic getMap(): Map<K, V> {\r\n\t\treturn this.map;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key to find in the Manager's list\r\n\t * @returns V\r\n\t */\r\n\tpublic get(key: K): V {\r\n\t\treturn this.map.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the keys of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<K>\r\n     * @memberof Manager\r\n     */\r\n\tpublic keys(): Array<K> {\r\n\t\treturn Array.from(this.map.keys());\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the values of all items stored in the Manager as an Array\r\n\t *\r\n\t * @returns Array<V>\r\n     * @memberof Manager\r\n\t */\r\n\tpublic values(): Array<V> {\r\n\t\treturn Array.from(this.map.values());\r\n\t}\r\n\r\n\t/**\r\n\t * Set a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key where the value will be stored\r\n\t * @param  {V} value - The value to store\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic set(key: K, value: V): Manager<K, V> {\r\n\t\tthis.map.set(key, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n    /**\r\n     * Adds a value to Manager, and uses the current size of the Manager as it's key, it works best when all the key in the Manager are numbers\r\n     *\r\n     * @public\r\n     * @param  {V} value\r\n     * @returns Manager<K, V>\r\n     */\r\n\tpublic add(value: V): Manager<K, V> {\r\n\t\t// @ts-ignore\r\n\t\tthis.set(this.size as K, value);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the total number of items stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @returns Number\r\n\t */\r\n\tpublic get size(): number {\r\n\t\treturn this.map.size;\r\n\t}\r\n\r\n    /**\r\n\t * Returns the last item in the Manager who's index is a certain distance from the last item in the Manager\r\n     *\r\n     * @param {number} [distance=1]\r\n     * @returns V | undefined\r\n     * @memberof Manager\r\n     */\r\n\tpublic last(distance: number = 1): V | undefined {\r\n\t\tlet key = this.keys()[this.size - distance];\r\n\t\treturn this.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the second last item in the Manager\r\n\t *\r\n\t * @public\r\n\t * @returns V\r\n\t */\r\n\tpublic prev(): V {\r\n\t\treturn this.last(2);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes a value stored in the Manager, via the key\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key for the key value pair to be removed\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic delete(key: K): Manager<K, V> {\r\n\t\tthis.map.delete(key);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Clear the Manager of all its contents\r\n\t *\r\n\t * @public\r\n\t * @returns Manager<K, V>\r\n\t */\r\n\tpublic clear(): Manager<K, V> {\r\n\t\tthis.map.clear();\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the Manager contains a certain key\r\n\t *\r\n\t * @public\r\n\t * @param {K} key\r\n\t * @returns boolean\r\n\t */\r\n\tpublic has(key: K): boolean {\r\n\t\treturn this.map.has(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order.\r\n\t *\r\n\t * @public\r\n\t * @returns IterableIterator<[K, V]>\r\n\t */\r\n\tpublic entries(): IterableIterator<[K, V]> {\r\n\t\treturn this.map.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates through the Managers contents, calling a callback function every iteration\r\n\t *\r\n\t * @param {*} [callback=(...args: any): void => { }]\r\n\t * @param {object} context\r\n\t * @returns Manager<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic forEach(\r\n\t\tcallback: any = (...args: any): void => { },\r\n\t\tcontext?: object\r\n\t): Manager<K, V> {\r\n\t\tthis.map.forEach(callback, context);\r\n\t\treturn this;\r\n\t}\r\n\r\n    /**\r\n     * Allows iteration via the for..of, learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators]\r\n     *\r\n     * @returns IterableIterator<[K, V]>\r\n     * @memberof Manager\r\n     */\r\n\tpublic [Symbol.iterator](): IterableIterator<[K, V]> {\r\n\t\treturn this.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the method of a certain name for all items that are currently installed\r\n\t *\r\n\t * @param {string} method\r\n\t * @param {Array<any>} [args=[]]\r\n\t * @returns Manager<K, V>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic methodCall(method: string, ...args: any): Manager<K, V> {\r\n\t\tthis.forEach((item: V) => {\r\n\t\t\t// @ts-ignore\r\n\t\t\titem[method](...args);\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Asynchronously calls the method of a certain name for all items that are currently installed, similar to methodCall\r\n\t *\r\n\t * @param {string} method\r\n\t * @param {Array<any>} [args=[]]\r\n\t * @returns Promise<Manager<K, V>>\r\n\t * @memberof Manager\r\n\t */\r\n\tpublic async asyncMethodCall(method: string, ...args: any): Promise<Manager<K, V>> {\r\n\t\tfor (let [, item] of this.map) {\r\n\t\t\t// @ts-ignore\r\n\t\t\tawait item[method](...args);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n}","import { Manager } from \"@okikio/manager\";\r\nimport { ConfigKeys } from \"./config\";\r\nimport { App } from \"./app\";\r\n\r\nexport type IAdvancedManager = AdvancedManager<any, ManagerItem>;\r\n\r\n/**\r\n * The base class for all AdvancedManager and AdvancedStorage items\r\n *\r\n * @export\r\n * @class ManagerItem\r\n */\r\nexport class ManagerItem {\r\n    /**\r\n     * The AdvancedManager or AdvancedStorage the ManagerItem is attached to\r\n     *\r\n     * @protected\r\n     * @type IAdvancedManager\r\n     * @memberof ManagerItem\r\n     */\r\n    protected manager: IAdvancedManager;\r\n\r\n    /**\r\n     * Creates an instance of ManagerItem.\r\n     * \r\n     * @memberof ManagerItem\r\n     */\r\n    constructor() { }\r\n\r\n    /**\r\n     * The getConfig method for accessing the Configuration of the current App\r\n     *\r\n     * @param {ConfigKeys} [value]\r\n     * @param {boolean} [brackets]\r\n     * @returns any\r\n     * @memberof ManagerItem\r\n     */\r\n    protected getConfig(value?: ConfigKeys, brackets?: boolean): any {\r\n        return this.manager.getConfig(value, brackets);\r\n    };\r\n\r\n    /**\r\n     * Run after the Manager Item has been registered\r\n     *\r\n     * @returns any\r\n     * @memberof ManagerItem\r\n     */\r\n    public install(): any { }\r\n\r\n    /**\r\n     * Register the current Manager Item's manager\r\n     *\r\n     * @param {IAdvancedManager} manager\r\n     * @returns ManagerItem\r\n     * @memberof ManagerItem\r\n     */\r\n    public register(manager: IAdvancedManager): ManagerItem {\r\n        this.manager = manager;\r\n        this.install();\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * A tweak to the Manager class that makes it self aware of the App class it's instantiated in\r\n *\r\n * @export\r\n * @class AdvancedManager\r\n * @extends {Manager<K, V>}\r\n * @template K\r\n * @template V\r\n */\r\nexport class AdvancedManager<K, V extends ManagerItem> extends Manager<K, V> {\r\n\t/**\r\n\t * The instance of the App class, the Manager is instantiated in\r\n\t *\r\n\t * @private\r\n\t * @type App\r\n\t * @memberof AdvancedManager\r\n\t */\r\n    private app: App;\r\n\r\n\t/**\r\n\t * Creates an instance of AdvancedManager.\r\n\t *\r\n\t * @param {App} app - The instance of the App class, the Manager is instantiated in\r\n\t * @memberof AdvancedManager\r\n\t */\r\n    constructor(app: App) {\r\n        super();\r\n        this.app = app;\r\n    }\r\n\r\n\t/**\r\n\t * Set a value stored in the Manager\r\n\t *\r\n\t * @public\r\n\t * @param  {K} key - The key where the value will be stored\r\n\t * @param  {V} value - The value to store\r\n\t * @returns AdvancedManager<K, V>\r\n\t */\r\n    public set(key: K, value: V) {\r\n        super.set(key, value);\r\n        typeof value.register === \"function\" && value.register(this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the instance the App class\r\n\t *\r\n\t * @returns App\r\n\t * @memberof AdvancedManager\r\n\t */\r\n    public getApp(): App {\r\n        return this.app;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the App config\r\n\t *\r\n     * @param {...any} args\r\n     * @returns any\r\n\t * @memberof AdvancedManager\r\n\t */\r\n    public getConfig(...args: any): any {\r\n        return this.app.getConfig(...args);\r\n    }\r\n}\r\n\r\nexport { Manager };","/**\r\n * Adds new methods to the native URL Object; it seemed cleaner than using a custom method or editing the prototype.\r\n *\r\n * This doesn't extend the **Class** object because it's meant to be a small extension of the native URL class.\r\n *\r\n * @export\r\n * @class _URL\r\n * @extends {URL}\r\n */\r\nexport class _URL extends URL {\r\n    // Read up on the native URL class [devdocs.io/dom/url]\r\n\t/**\r\n\t * Creates an instance of _URL.\r\n\t *\r\n     * @param {(string | _URL | URL | Location)} [url=window.location.pathname]\r\n\t * @memberof _URL\r\n\t */\r\n    constructor(url: any = window.location.href) {\r\n        super(url instanceof URL ? url.href : url, window.location.origin);\r\n    }\r\n\r\n    /**\r\n     * Returns the pathname with the hash\r\n     *\r\n     * @returns string\r\n     * @memberof _URL\r\n     */\r\n    public getFullPath(): string {\r\n        return `${this.pathname}${this.hash}`;\r\n    }\r\n\r\n    /**\r\n     * Returns the actual hash without the hashtag\r\n     *\r\n     * @returns string\r\n     * @memberof _URL\r\n     */\r\n    public getHash(): string {\r\n        return this.hash.slice(1);\r\n    }\r\n\r\n    /**\r\n\t * Removes the hash from the full URL for a clean URL string\r\n\t *\r\n\t * @returns string\r\n\t * @memberof _URL\r\n\t */\r\n    public clean(): string {\r\n        return this.toString().replace(/(\\/#.*|\\/|#.*)$/, '');\r\n    }\r\n\r\n\t/**\r\n\t * Returns the pathname of a URL\r\n\t *\r\n\t * @returns string\r\n\t * @memberof _URL\r\n\t */\r\n    public getPathname(): string {\r\n        return this.pathname;\r\n    }\r\n\r\n\t/**\r\n\t * Compares this **_URL** to another **_URL**\r\n\t *\r\n\t * @param {_URL} url\r\n\t * @returns boolean\r\n\t * @memberof _URL\r\n\t */\r\n    public equalTo(url: _URL): boolean {\r\n        return this.clean() == url.clean();\r\n    }\r\n\r\n\t/**\r\n\t * Compares the pathname of two URLs to each other\r\n\t *\r\n\t * @static\r\n\t * @param {_URL} a\r\n\t * @param {_URL} b\r\n\t * @returns boolean\r\n\t * @memberof _URL\r\n\t */\r\n    static equal(a: _URL | string, b: _URL | string): boolean {\r\n        let urlA = a instanceof _URL ? a : new _URL(a);\r\n        let urlB = b instanceof _URL ? b : new _URL(b);\r\n        return urlA.equalTo(urlB);\r\n    }\r\n}","import { Manager } from \"./manager\";\r\nimport { _URL } from \"./url\";\r\n\r\nexport type Trigger = HTMLAnchorElement | \"HistoryManager\" | \"popstate\" | \"back\" | \"forward\";\r\n\r\nexport interface ICoords {\r\n\treadonly x: number;\r\n\treadonly y: number;\r\n}\r\n\r\nexport interface IStateData {\r\n\tscroll: ICoords;\r\n\t[key: string]: any;\r\n}\r\n\r\nexport interface IState {\r\n\turl: _URL;\r\n\tindex?: number;\r\n\ttransition: string;\r\n\tdata: IStateData;\r\n}\r\n\r\n/**\r\n * A quick snapshot of page coordinates, e.g. scroll positions\r\n *\r\n * @export\r\n * @class Coords\r\n * @implements {ICoords}\r\n */\r\nexport class Coords implements ICoords {\r\n\tpublic x: number;\r\n\tpublic y: number;\r\n\r\n\t/**\r\n\t * Creates an instance of Coords.\r\n\t *\r\n\t * @param {number} [x=window.scrollX]\r\n\t * @param {number} [y=window.scrollY]\r\n\t * @memberof Coords\r\n\t */\r\n\tconstructor(x: number = window.scrollX, y: number = window.scrollY) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n}\r\n\r\n/**\r\n * Represents the current status of the page consisting of properties like: url, transition, and data\r\n *\r\n * @export\r\n * @class State\r\n */\r\nexport class State {\r\n\t/**\r\n\t * The current state data\r\n\t *\r\n\t * @private\r\n\t * @type IState\r\n\t * @memberof State\r\n\t */\r\n\tprivate state: IState;\r\n\r\n\t/**\r\n\t * Creates an instance of State.\r\n\t * @param {IState} {\r\n     *         url = new _URL(),\r\n\t *         index = 0,\r\n\t *         transition = \"default\",\r\n\t *         data = {\r\n\t *             scroll: new StateCoords(),\r\n\t *             trigger: \"HistoryManager\"\r\n\t *         }\r\n\t *     }\r\n\t * @memberof State\r\n\t */\r\n\tconstructor(state: IState = {\r\n\t\turl: new _URL(),\r\n\t\tindex: 0,\r\n\t\ttransition: \"default\",\r\n\t\tdata: {\r\n\t\t\tscroll: new Coords(),\r\n\t\t\ttrigger: \"HistoryManager\"\r\n\t\t}\r\n\t}) {\r\n\t\tthis.state = state;\r\n\t}\r\n\r\n\t/**\r\n\t * Get state index\r\n\t *\r\n\t * @returns number\r\n\t * @memberof State\r\n\t */\r\n\tpublic getIndex(): number {\r\n\t\treturn this.state.index;\r\n\t}\r\n\r\n\t/**\r\n\t * Set state index\r\n\t *\r\n\t * @param {number} index\r\n\t * @returns State\r\n\t * @memberof State\r\n\t */\r\n\tpublic setIndex(index: number): State {\r\n\t\tthis.state.index = index;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Get state URL\r\n\t *\r\n\t * @returns _URL\r\n\t * @memberof State\r\n\t */\r\n\tpublic getURL(): _URL {\r\n\t\treturn this.state.url;\r\n\t}\r\n\r\n\t/**\r\n\t * Get state URL as a string\r\n\t *\r\n\t * @returns string\r\n\t * @memberof State\r\n\t */\r\n\tpublic getURLPathname(): string {\r\n\t\treturn this.state.url.getPathname();\r\n\t}\r\n\r\n\t/**\r\n\t * Get state transition\r\n\t *\r\n\t * @returns string\r\n\t * @memberof State\r\n\t */\r\n\tpublic getTransition(): string {\r\n\t\treturn this.state.transition;\r\n\t}\r\n\r\n\t/**\r\n\t * Get state data\r\n\t *\r\n\t * @returns IStateData\r\n\t * @memberof State\r\n\t */\r\n\tpublic getData(): IStateData {\r\n\t\treturn this.state.data;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the State as an Object\r\n\t *\r\n\t * @returns object\r\n\t * @memberof State\r\n\t */\r\n\tpublic toJSON(): object {\r\n\t\tconst { url, index, transition, data }: IState = this.state;\r\n\t\treturn {\r\n\t\t\turl: url.getFullPath(), index, transition, data\r\n\t\t};\r\n\t}\r\n}\r\n\r\n/**\r\n * History of the site, stores only the State class\r\n *\r\n * @export\r\n * @class HistoryManager\r\n * @extends {Manager<number, State>}\r\n */\r\nexport class HistoryManager extends Manager<number, State> {\r\n\t/**\r\n\t * Creates an instance of the HistoryManager class, which inherits properties and methods from the Storage class.\r\n\t *\r\n\t * @memberof HistoryManager\r\n\t * @constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the index of the state before adding to HistoryManager\r\n\t *\r\n\t * @param {State} value\r\n\t * @returns HistoryManager\r\n\t * @memberof HistoryManager\r\n\t */\r\n\tpublic add(value: State): HistoryManager {\r\n\t\tlet state = value;\r\n\t\tlet index = this.size;\r\n\t\tsuper.add(state);\r\n\t\tstate.setIndex(index);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Quick way to add a State to the HistoryManager\r\n\t *\r\n\t * @param {IState} value\r\n\t * @returns HistoryManager\r\n\t * @memberof HistoryManager\r\n\t */\r\n\tpublic addState(value: IState | State): HistoryManager {\r\n\t\tlet state = value instanceof State ? value : new State(value);\r\n\t\tthis.add(state);\r\n\t\treturn this;\r\n\t}\r\n}\r\n","import { Manager, ManagerItem, AdvancedManager } from \"./manager\";\r\nimport { _URL } from \"./url\";\r\nimport { App } from \"./app\";\r\n\r\n/**\r\n * Parses strings to DOM\r\n */\r\nexport const PARSER: DOMParser = new DOMParser();\r\n\r\n/**\r\n * A page represents the DOM elements that create each page\r\n *\r\n * @export\r\n * @class Page\r\n */\r\nexport class Page extends ManagerItem {\r\n\t/**\r\n\t * Holds the DOM of the current page\r\n\t *\r\n\t * @private\r\n\t * @type Document\r\n\t * @memberof Page\r\n\t */\r\n    private dom: Document;\r\n\r\n\t/**\r\n\t * Holds the wrapper element to be swapped out of each Page\r\n\t *\r\n\t * @private\r\n\t * @type HTMLElement\r\n\t * @memberof Page\r\n\t */\r\n    private wrapper: HTMLElement;\r\n\r\n\t/**\r\n\t * Holds the title of each page\r\n\t *\r\n\t * @private\r\n\t * @type string\r\n\t * @memberof Page\r\n\t */\r\n    private title: string;\r\n\r\n\t/**\r\n\t * Holds the head element of each page\r\n\t *\r\n\t * @private\r\n\t * @type Element\r\n\t * @memberof Page\r\n\t */\r\n    private head: Element;\r\n\r\n\t/**\r\n\t * Holds the body element of each page\r\n\t *\r\n\t * @private\r\n\t * @type Element\r\n\t * @memberof Page\r\n\t */\r\n    private body: Element;\r\n\r\n\t/**\r\n\t * The URL of the current page\r\n\t *\r\n\t * @private\r\n\t * @type _URL\r\n\t * @memberof Page\r\n\t */\r\n    private url: _URL;\r\n\r\n\t/**\r\n\t * Creates an instance of Page, it also creates a new page from response text, or a Document Object\r\n\t *\r\n\t * @param {_URL} [url=new _URL()]\r\n\t * @param {(string | Document)} [dom=document]\r\n\t * @memberof Page\r\n\t */\r\n    constructor(url: _URL = new _URL(), dom: string | Document = document) {\r\n        super();\r\n        this.url = url;\r\n        if (typeof dom === \"string\") {\r\n            this.dom = PARSER.parseFromString(dom, \"text/html\");\r\n        } else this.dom = dom || document;\r\n\r\n        const { title, head, body } = this.dom;\r\n        this.title = title;\r\n        this.head = head;\r\n        this.body = body;\r\n    }\r\n\r\n    /**\r\n     * Runs once the the manager and config have been registered\r\n     *\r\n     * @returns void\r\n     * @memberof Page\r\n     */\r\n    public install(): void {\r\n        this.wrapper = this.body.querySelector(this.getConfig(\"wrapperAttr\"));\r\n    }\r\n\r\n\t/**\r\n\t * Returns the current page's URL\r\n\t *\r\n\t * @returns _URL\r\n\t * @memberof Page\r\n\t */\r\n    public getURL(): _URL {\r\n        return this.url;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the current page's URL\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Page\r\n\t */\r\n    public getPathname(): string {\r\n        return this.url.pathname;\r\n    }\r\n\r\n\t/**\r\n\t * The page title\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Page\r\n\t */\r\n    public getTitle(): string {\r\n        return this.title;\r\n    }\r\n\r\n\t/**\r\n\t * The page's head element\r\n\t *\r\n\t * @returns Element\r\n\t * @memberof Page\r\n\t */\r\n    public getHead(): Element {\r\n        return this.head;\r\n    }\r\n\r\n\t/**\r\n\t * The page's body element\r\n\t *\r\n\t * @returns Element\r\n\t * @memberof Page\r\n\t */\r\n    public getBody(): Element {\r\n        return this.body;\r\n    }\r\n\r\n\t/**\r\n\t * The page's wrapper element\r\n\t *\r\n\t * @returns HTMLElement\r\n\t * @memberof Page\r\n\t */\r\n    public getWrapper(): HTMLElement {\r\n        return this.wrapper;\r\n    }\r\n\r\n\t/**\r\n\t * The page's document\r\n\t *\r\n\t * @returns Document\r\n\t * @memberof Page\r\n\t */\r\n    public getDOM(): Document {\r\n        return this.dom;\r\n    }\r\n}\r\n\r\n/**\r\n * Controls which page to be load\r\n *\r\n * @export\r\n * @class PageManager\r\n * @extends {AdvancedManager<string, Page>}\r\n */\r\nexport class PageManager extends AdvancedManager<string, Page> {\r\n    /**\r\n     * Stores all URLs that are currently loading\r\n     *\r\n     * @protected\r\n     * @type Manager<string, Promise<string>>\r\n     * @memberof PageManager\r\n     */\r\n    protected loading: Manager<string, Promise<string>> = new Manager();\r\n\r\n\t/**\r\n\t * Creates an instance of the PageManager\r\n\t *\r\n     * @param {App} app\r\n\t * @memberof PageManager\r\n\t */\r\n    constructor(app: App) {\r\n        super(app);\r\n        let URLString = new _URL().getPathname();\r\n        this.set(URLString, new Page());\r\n    }\r\n\r\n    /**\r\n     * Returns the loading Manager\r\n     *\r\n     * @returns Manager<string, Promise<string>>\r\n     * @memberof PageManager\r\n     */\r\n    public getLoading(): Manager<string, Promise<string>> {\r\n        return this.loading;\r\n    }\r\n\r\n    /**\r\n     * Load from cache or by requesting URL via a fetch request, avoid requesting for the same thing twice by storing the fetch request in \"this.loading\"\r\n     *\r\n     * @param {(_URL | string)} [_url=new _URL()]\r\n     * @returns Promise<Page>\r\n     * @memberof PageManager\r\n     */\r\n    public async load(_url: _URL | string = new _URL()): Promise<Page> {\r\n        let url: _URL = _url instanceof URL ? _url : new _URL(_url);\r\n        let urlString: string = url.getPathname();\r\n        let page: Page, request: Promise<string>;\r\n        if (this.has(urlString)) {\r\n            page = this.get(urlString);\r\n            return Promise.resolve(page);\r\n        }\r\n\r\n        if (!this.loading.has(urlString)) {\r\n            request = this.request(urlString);\r\n            this.loading.set(urlString, request);\r\n        } else request = this.loading.get(urlString);\r\n\r\n        let response = await request;\r\n        this.loading.delete(urlString);\r\n\r\n        page = new Page(url, response);\r\n        this.set(urlString, page);\r\n        return page;\r\n    }\r\n\r\n    /**\r\n     * Starts a fetch request\r\n     *\r\n     * @param {string} url\r\n     * @returns Promise<string>\r\n     * @memberof PageManager\r\n     */\r\n    public async request(url: string): Promise<string> {\r\n        const headers = new Headers(this.getConfig(\"headers\"));\r\n        const timeout = window.setTimeout(() => {\r\n            window.clearTimeout(timeout);\r\n            throw \"Request Timed Out!\";\r\n        }, this.getConfig(\"timeout\"));\r\n\r\n        try {\r\n            let response = await fetch(url, {\r\n                mode: 'same-origin',\r\n                method: \"GET\",\r\n                headers: headers,\r\n                cache: \"default\",\r\n                credentials: \"same-origin\",\r\n            });\r\n\r\n            window.clearTimeout(timeout);\r\n            if (response.status >= 200 && response.status < 300) {\r\n                return await response.text();\r\n            }\r\n\r\n            const err = new Error(response.statusText || \"\" + response.status);\r\n            throw err;\r\n        } catch (err) {\r\n            window.clearTimeout(timeout);\r\n            throw err;\r\n        }\r\n    }\r\n}","import { Manager } from \"@okikio/manager\";\r\n\r\nexport type ListenerCallback = ((...args: any) => void);\r\nexport interface IListener {\r\n    readonly callback: ListenerCallback;\r\n    readonly scope: object;\r\n    readonly name: string;\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Listener\r\n */\r\nexport class Listener {\r\n\t/**\r\n\t * The current listener data\r\n\t *\r\n\t * @private\r\n\t * @type IListener\r\n\t * @memberof Listener\r\n\t */\r\n    private listener: IListener;\r\n\r\n\t/**\r\n\t * Creates an instance of Listener.\r\n\t *\r\n\t * @param {IListener} { callback = () => { }, scope = null, name = \"event\" }\r\n\t * @memberof Listener\r\n\t */\r\n    constructor({\r\n        callback = () => { },\r\n        scope = null,\r\n        name = \"event\",\r\n    }: IListener) {\r\n        this.listener = { callback, scope, name };\r\n    }\r\n\r\n\t/**\r\n\t * Returns the callback Function of the Listener\r\n\t *\r\n\t * @returns ListenerCallback\r\n\t * @memberof Listener\r\n\t */\r\n    public getCallback(): ListenerCallback {\r\n        return this.listener.callback;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the scope as an Object, from the Listener\r\n\t *\r\n\t * @returns object\r\n\t * @memberof Listener\r\n\t */\r\n    public getScope(): object {\r\n        return this.listener.scope;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the event as a String, from the Listener\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Listener\r\n\t */\r\n    public getEventName(): string {\r\n        return this.listener.name;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the listener as an Object\r\n\t *\r\n\t * @returns IListener\r\n\t * @memberof Listener\r\n\t */\r\n    public toJSON(): IListener {\r\n        return this.listener;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a new event listener consisting of properties like: callback, scope, name\r\n *\r\n * @export\r\n * @class Event\r\n * @extends {Manager<number, Listener>}\r\n */\r\nexport class Event extends Manager<number, Listener> {\r\n\t/**\r\n\t * The name of the event\r\n\t *\r\n\t * @private\r\n\t * @type string\r\n\t * @memberof Event\r\n\t */\r\n    private name: string;\r\n\r\n\t/**\r\n\t * Creates an instance of Event.\r\n\t *\r\n\t * @param {string} [name=\"event\"]\r\n\t * @memberof Event\r\n\t */\r\n    constructor(name: string = \"event\") {\r\n        super();\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport type EventInput = string | object | Array<string>;\r\n\r\n/**\r\n * An event emitter\r\n *\r\n * @export\r\n * @class EventEmitter\r\n * @extends {Manager<string, Event>}\r\n */\r\nexport class EventEmitter extends Manager<string, Event> {\r\n\t/**\r\n\t * Creates an instance of EventEmitter.\r\n\t *\r\n\t * @memberof EventEmitter\r\n\t */\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n\t * Gets events, if event doesn't exist create a new Event\r\n     *\r\n     * @param {string} name\r\n     * @returns Event\r\n     * @memberof EventEmitter\r\n     */\r\n    public getEvent(name: string): Event {\r\n        let event = this.get(name);\r\n        if (!(event instanceof Event)) {\r\n            this.set(name, new Event(name));\r\n            return this.get(name);\r\n        }\r\n\r\n        return event;\r\n    }\r\n\t/**\r\n\t * Creates a new listener and adds it to the event\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {ListenerCallback} callback\r\n\t * @param {object} scope\r\n\t * @returns Event\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public newListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event = this.getEvent(name);\r\n        event.add(new Listener({ name, callback, scope }));\r\n        return event;\r\n    }\r\n\r\n\t/**\r\n\t * Adds a listener for a given event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback | object} callback\r\n\t * @param {object} scope\r\n\t * @returns\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public on(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            this.newListener(_name, _callback, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Removes a listener from an event\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {ListenerCallback} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns Event\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public removeListener(\r\n        name: string,\r\n        callback: ListenerCallback,\r\n        scope: object\r\n    ): Event {\r\n        let event: Event = this.get(name);\r\n        if (event instanceof Event && callback) {\r\n            let i = 0,\r\n                len: number = event.size,\r\n                value: Listener;\r\n            let listener = new Listener({ name, callback, scope });\r\n            for (; i < len; i++) {\r\n                value = event.get(i);\r\n\r\n                if (\r\n                    value.getCallback() === listener.getCallback() &&\r\n                    value.getScope() === listener.getScope()\r\n                )\r\n                    break;\r\n            }\r\n\r\n            event.delete(i);\r\n        }\r\n\r\n        return event;\r\n    }\r\n\r\n\t/**\r\n\t * Removes a listener from a given event, or it just completely removes an event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback | object} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public off(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events == \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<any>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            if (_callback) {\r\n                this.removeListener(_name, _callback, _scope);\r\n            } else this.delete(_name);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Adds a one time event listener for an event,\r\n     * do note, you can't use .off to remove events listeners for the kind of event, \r\n     * however, you can still remove the entire event\r\n\t *\r\n\t * @param {EventInput} events\r\n\t * @param {ListenerCallback | object} [callback]\r\n\t * @param {object} [scope]\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public once(\r\n        events: EventInput,\r\n        callback?: ListenerCallback | object,\r\n        scope?: object\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        let _name: string;\r\n        let _callback: ListenerCallback;\r\n        let isObject = typeof events === \"object\" && !Array.isArray(events);\r\n\r\n        let _scope: object = isObject ? callback : scope;\r\n        if (!isObject) _callback = (callback as ListenerCallback);\r\n\r\n        // Loop through the list of events\r\n        Object.keys(events).forEach(key => {\r\n            // Select the name of the event from the list\r\n            // Remember events can be {String | Object | Array<string>}\r\n\r\n            // Check If events is an Object (JSON like Object, and not an Array)\r\n            if (isObject) {\r\n                _name = key;\r\n                _callback = events[key];\r\n            } else {\r\n                _name = events[key];\r\n            }\r\n\r\n            let onceFn: ListenerCallback = (...args) => {\r\n                if (isObject) {\r\n                    _name = key;\r\n                    _callback = events[key];\r\n                } else {\r\n                    _name = events[key];\r\n                }\r\n\r\n                this.off(_name, onceFn, _scope);\r\n                _callback.apply(_scope, args);\r\n            };\r\n\r\n            this.on(_name, onceFn, _scope);\r\n        }, this);\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Call all listeners within an event\r\n\t *\r\n\t * @param {(string | Array<any>)} events\r\n     * @param {...any} args\r\n\t * @returns EventEmitter\r\n\t * @memberof EventEmitter\r\n\t */\r\n    public emit(\r\n        events: string | Array<any>,\r\n        ...args: any\r\n    ): EventEmitter {\r\n        // If there is no event break\r\n        if (typeof events == \"undefined\") return this;\r\n\r\n        // Create a new event every space\r\n        if (typeof events == \"string\") events = events.split(/\\s/g);\r\n\r\n        // Loop through the list of events\r\n        events.forEach((event: string) => {\r\n            let _event: Event = this.get(event);\r\n\r\n            if (_event instanceof Event) {\r\n                _event.forEach((listener: Listener) => {\r\n                    let { callback, scope }: IListener = listener.toJSON();\r\n                    callback.apply(scope, args);\r\n                });\r\n            }\r\n        }, this);\r\n        return this;\r\n    }\r\n}","import { AdvancedManager, ManagerItem } from \"./manager\";\r\nimport { TransitionManager } from \"./transition\";\r\nimport { HistoryManager } from \"./history\";\r\nimport { EventEmitter } from \"./emitter\";\r\nimport { PageManager } from \"./page\";\r\nimport { App } from \"./app\";\r\n\r\n/**\r\n * Controls specific kinds of actions that require JS\r\n *\r\n * @export\r\n * @class Service\r\n */\r\nexport class Service extends ManagerItem {\r\n\t/**\r\n\t * Stores access to the App class's EventEmitter\r\n\t *\r\n\t * @protected\r\n\t * @type EventEmitter\r\n\t * @memberof Service\r\n\t */\r\n\tprotected EventEmitter: EventEmitter;\r\n\r\n\t/**\r\n\t * Stores access to the App class's PageManager\r\n\t *\r\n\t * @protected\r\n\t * @type PageManager\r\n\t * @memberof Service\r\n\t */\r\n\tprotected PageManager: PageManager;\r\n\r\n\t/**\r\n\t * Stores access to the App class's HistoryManager\r\n\t *\r\n\t * @protected\r\n\t * @type HistoryManager\r\n\t * @memberof Service\r\n\t */\r\n\tprotected HistoryManager: HistoryManager;\r\n\r\n\t/**\r\n\t * Stores the ServiceManager the service is install on\r\n\t *\r\n\t * @protected\r\n\t * @type ServiceManager\r\n\t * @memberof Service\r\n\t */\r\n\tprotected ServiceManager: ServiceManager;\r\n\r\n\t/**\r\n\t * Stores access to the App's TransitionManager\r\n\t *\r\n\t * @protected\r\n\t * @type TransitionManager\r\n\t * @memberof Service\r\n\t */\r\n\tprotected TransitionManager: TransitionManager;\r\n\r\n\t/**\r\n\t * Method is run once when Service is installed on a ServiceManager\r\n     *\r\n\t * @memberof Service\r\n\t */\r\n\tpublic install(): void {\r\n\t\tlet app = this.manager.getApp();\r\n\t\tthis.PageManager = app.getPages();\r\n\t\tthis.EventEmitter = app.getEmitter();\r\n\t\tthis.HistoryManager = app.getHistory();\r\n\t\tthis.ServiceManager = app.getServices();\r\n\t\tthis.TransitionManager = app.getTransitions();\r\n\t}\r\n\r\n\t// Called on start of Service\r\n\tpublic boot(): void { }\r\n\r\n\t// Initialize events\r\n\tpublic initEvents(): void { }\r\n\r\n\t// Stop events\r\n\tpublic stopEvents(): void { }\r\n\r\n\t// Stop services\r\n\tpublic stop(): void {\r\n\t\tthis.stopEvents();\r\n\t}\r\n}\r\n\r\n/**\r\n * The Service Manager controls the lifecycle of all services in an App\r\n *\r\n * @export\r\n * @class ServiceManager\r\n * @extends {AdvancedManager<number, Service>}\r\n */\r\nexport class ServiceManager extends AdvancedManager<number, Service> {\r\n    /**\r\n     * Creates an instance of ServiceManager.\r\n     *\r\n     * @param {App} app\r\n     * @memberof ServiceManager\r\n     */\r\n\tconstructor(app: App) {\r\n\t\tsuper(app);\r\n\t}\r\n\r\n\t/**\r\n\t * Call the boot method for all Services\r\n\t *\r\n\t * @returns ServiceManager\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic boot(): ServiceManager {\r\n\t\tthis.methodCall(\"boot\");\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Call the initEvents method for all Services\r\n\t *\r\n\t * @returns ServiceManager\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic initEvents(): ServiceManager {\r\n\t\tthis.methodCall(\"initEvents\");\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Call the stopEvents method for all Services\r\n\t *\r\n\t * @returns ServiceManager\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic stopEvents(): ServiceManager {\r\n\t\tthis.methodCall(\"stopEvents\");\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Call the stop method for all Services\r\n\t *\r\n\t * @returns ServiceManager\r\n\t * @memberof ServiceManager\r\n\t */\r\n\tpublic stop(): ServiceManager {\r\n\t\tthis.methodCall(\"stop\");\r\n\t\treturn this;\r\n\t}\r\n}","import { AdvancedManager, ManagerItem } from \"./manager\";\r\nimport { EventEmitter } from \"./emitter\";\r\nimport { Trigger } from \"./history\";\r\nimport { Page } from \"./page\";\r\nimport { App } from \"./app\";\r\n\r\n/**\r\n * The async function type, allows for smooth transition between Promises\r\n */\r\nexport type asyncFn = (err?: any, value?: any) => void;\r\nexport interface ITransition {\r\n    oldPage: Page,\r\n    newPage: Page,\r\n    trigger: Trigger\r\n}\r\nexport interface ITransitionData {\r\n    from?: Page,\r\n    to?: Page,\r\n    trigger?: Trigger,\r\n    done: asyncFn\r\n}\r\n\r\n/**\r\n * Controls the animation between pages\r\n *\r\n * @export\r\n * @class Transition\r\n */\r\nexport class Transition extends ManagerItem {\r\n\t/**\r\n\t * Transition name\r\n\t *\r\n\t * @protected\r\n\t * @type string\r\n\t * @memberof Transition\r\n\t */\r\n    protected name: string = \"Transition\";\r\n\r\n\t/**\r\n\t * The page to transition from\r\n\t *\r\n\t * @protected\r\n\t * @type Page\r\n\t * @memberof Transition\r\n\t */\r\n    protected oldPage: Page;\r\n\r\n\t/**\r\n\t * Page to transition to\r\n\t *\r\n\t * @protected\r\n\t * @type Page\r\n\t * @memberof Transition\r\n\t */\r\n    protected newPage: Page;\r\n\r\n\t/**\r\n\t * What triggered the transition to occur\r\n\t *\r\n\t * @protected\r\n\t * @type Trigger\r\n\t * @memberof Transition\r\n\t */\r\n    protected trigger: Trigger;\r\n\r\n    /**\r\n     * Creates an instance of Transition.\r\n     *\r\n     * @memberof Transition\r\n     */\r\n    constructor() { super(); }\r\n\r\n\t/**\r\n\t * Initialize the transition\r\n\t *\r\n\t * @param {ITransition} {\r\n\t * \t\toldPage,\r\n\t * \t\tnewPage,\r\n\t * \t\ttrigger\r\n\t * \t}\r\n     * @returns Transition\r\n\t * @memberof Transition\r\n\t */\r\n    public init({\r\n        oldPage,\r\n        newPage,\r\n        trigger\r\n    }: ITransition): Transition {\r\n        this.oldPage = oldPage;\r\n        this.newPage = newPage;\r\n        this.trigger = trigger;\r\n        this.boot();\r\n        return this;\r\n    }\r\n\r\n    // Called on start of Transition\r\n    public boot(): void { }\r\n\r\n    // Initialize events\r\n    public initEvents(): void { }\r\n\r\n    // Stop events\r\n    public stopEvents(): void { }\r\n\r\n    // Stop services\r\n    public stop(): void {\r\n        this.stopEvents();\r\n    }\r\n\r\n\t/**\r\n\t * Returns the Transition's name\r\n\t *\r\n\t * @returns string\r\n\t * @memberof Transition\r\n\t */\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the Transition's old page\r\n\t *\r\n\t * @returns Page\r\n\t * @memberof Transition\r\n\t */\r\n    public getOldPage(): Page {\r\n        return this.oldPage;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the Transition's new page\r\n\t *\r\n\t * @returns Page\r\n\t * @memberof Transition\r\n\t */\r\n    public getNewPage(): Page {\r\n        return this.newPage;\r\n    }\r\n\r\n\t/**\r\n\t * Returns the Transition's trigger\r\n\t *\r\n\t * @returns Trigger\r\n\t * @memberof Transition\r\n\t */\r\n    public getTrigger(): Trigger {\r\n        return this.trigger;\r\n    }\r\n\r\n    // Based off the highwayjs Transition class\r\n\t/**\r\n\t * Transition from current page\r\n\t *\r\n\t * @param {ITransitionData} { from, trigger, done }\r\n\t * @memberof Transition\r\n\t */\r\n    public out({ done }: ITransitionData): any {\r\n        done();\r\n    }\r\n\r\n\t/**\r\n\t * Transition into the next page\r\n\t *\r\n\t * @param {ITransitionData} { from, to, trigger, done }\r\n\t * @memberof Transition\r\n\t */\r\n    public in({ done }: ITransitionData): any {\r\n        done();\r\n    }\r\n\r\n    /**\r\n     * Starts the transition\r\n     *\r\n     * @returns Promise<Transition>\r\n     * @memberof Transition\r\n     */\r\n    public async start(EventEmitter: EventEmitter): Promise<Transition> {\r\n        let fromWrapper = this.oldPage.getWrapper();\r\n        let toWrapper = this.newPage.getWrapper();\r\n        document.title = this.newPage.getTitle();\r\n\r\n        return new Promise(async finish => {\r\n            EventEmitter.emit(\"BEFORE_TRANSITION_OUT\");\r\n            await new Promise(done => {\r\n                let outMethod: Promise<any> = this.out({\r\n                    from: this.oldPage,\r\n                    trigger: this.trigger,\r\n                    done\r\n                });\r\n\r\n                if (outMethod.then)\r\n                    outMethod.then(done);\r\n            });\r\n\r\n            EventEmitter.emit(\"AFTER_TRANSITION_OUT\");\r\n\r\n            await new Promise(done => {\r\n                fromWrapper.insertAdjacentElement('beforebegin', toWrapper);\r\n                fromWrapper.remove();\r\n                done();\r\n            });\r\n\r\n            EventEmitter.emit(\"BEFORE_TRANSITION_IN\");\r\n\r\n            await new Promise(done => {\r\n                let inMethod: Promise<any> = this.in({\r\n                    from: this.oldPage,\r\n                    to: this.newPage,\r\n                    trigger: this.trigger,\r\n                    done\r\n                });\r\n\r\n                if (inMethod.then)\r\n                    inMethod.then(done);\r\n            });\r\n\r\n            EventEmitter.emit(\"AFTER_TRANSITION_IN\");\r\n            finish();\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Controls which animation between pages to use\r\n *\r\n * @export\r\n * @class TransitionManager\r\n * @extends {AdvancedManager<string, Transition>}\r\n */\r\nexport class TransitionManager extends AdvancedManager<string, Transition> {\r\n\t/**\r\n\t * Creates an instance of the TransitionManager\r\n\t *\r\n     * @param {App} app\r\n\t * @memberof TransitionManager\r\n\t */\r\n    constructor(app: App) { super(app); }\r\n\r\n\t/**\r\n\t * Quick way to add a Transition to the TransitionManager\r\n\t *\r\n\t * @param {Transition} value\r\n\t * @returns TransitionManager\r\n\t * @memberof TransitionManager\r\n\t */\r\n    public add(value: Transition): TransitionManager {\r\n        let name = value.getName();\r\n        this.set(name, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Runs a transition\r\n     *\r\n     * @param {{ name: string, oldPage: Page, newPage: Page, trigger: Trigger }} { name, oldPage, newPage, trigger }\r\n     * @returns Promise<void>\r\n     * @memberof TransitionManager\r\n     */\r\n    public async boot({ name, oldPage, newPage, trigger }: { name: string, oldPage: Page, newPage: Page, trigger: Trigger }): Promise<Transition> {\r\n        let transition: Transition = this.get(name);\r\n        transition.init({\r\n            oldPage,\r\n            newPage,\r\n            trigger\r\n        });\r\n\r\n        let EventEmitter = this.getApp().getEmitter();\r\n        return await transition.start(EventEmitter);\r\n    }\r\n\r\n\t/**\r\n\t * Call the initEvents method for all Transitions\r\n\t *\r\n\t * @returns TransitionManager\r\n\t * @memberof TransitionManager\r\n\t */\r\n    public initEvents(): TransitionManager {\r\n        this.methodCall(\"initEvents\");\r\n        return this;\r\n    }\r\n\r\n\t/**\r\n\t * Call the stopEvents method for all Transitions\r\n\t *\r\n\t * @returns TransitionManager\r\n\t * @memberof TransitionManager\r\n\t */\r\n    public stopEvents(): TransitionManager {\r\n        this.methodCall(\"stopEvents\");\r\n        return this;\r\n    }\r\n}","import { ManagerItem, AdvancedManager, Manager } from \"./manager\";\r\nimport { Service } from \"./service\";\r\nimport { App } from \"./app\";\r\n\r\nexport interface IBlockInit {\r\n    name?: string;\r\n    rootElement?: HTMLElement;\r\n    selector?: string;\r\n    index?: number;\r\n};\r\n\r\n/**\r\n * Services that interact with specific Components to achieve certain actions\r\n *\r\n * @export\r\n * @class Block\r\n * @extends {Service}\r\n */\r\nexport class Block extends Service {\r\n    /**\r\n     * The name of the Block\r\n     *\r\n     * @protected\r\n     * @type string\r\n     * @memberof Block\r\n     */\r\n    protected name: string;\r\n\r\n    /**\r\n     * Query selector string \r\n     *\r\n     * @protected\r\n     * @type string\r\n     * @memberof Block\r\n     */\r\n    protected selector: string;\r\n\r\n    /**\r\n     * Index of Block in a BlockManager \r\n     *\r\n     * @protected\r\n     * @type number\r\n     * @memberof Block\r\n     */\r\n    protected index: number;\r\n\r\n    /**\r\n     * The id of an instance of a Block \r\n     *\r\n     * @protected\r\n     * @type {string}\r\n     * @memberof Block\r\n     */\r\n    protected id: string;\r\n\r\n    /**\r\n     * The Root Element of a Block\r\n     *\r\n     * @protected\r\n     * @type HTMLElement\r\n     * @memberof Block\r\n     */\r\n    protected rootElement: HTMLElement;\r\n\r\n    /**\r\n     * It initializes the Block\r\n     *\r\n     * @param {IBlockInit} [{ name, rootElement, selector, index }]\r\n     * @memberof Block\r\n     */\r\n    public init({ name, rootElement, selector, index }: IBlockInit) {\r\n        this.rootElement = rootElement;\r\n        this.name = name;\r\n        this.selector = selector;\r\n        this.index = index;\r\n    }\r\n\r\n    /**\r\n     * Get Root Element\r\n     *\r\n     * @returns HTMLElement\r\n     * @memberof Block\r\n     */\r\n    public getRootElement(): HTMLElement {\r\n        return this.rootElement;\r\n    }\r\n\r\n    /**\r\n     * Get Selector\r\n     *\r\n     * @returns string\r\n     * @memberof Block\r\n     */\r\n    public getSelector(): string {\r\n        return this.selector;\r\n    }\r\n\r\n    /**\r\n     * Get Index\r\n     *\r\n     * @returns number\r\n     * @memberof Block\r\n     */\r\n    public getIndex(): number {\r\n        return this.index;\r\n    }\r\n\r\n    /**\r\n     * Get Block ID\r\n     *\r\n     * @returns string\r\n     * @memberof Block\r\n     */\r\n    public getID(): string {\r\n        return this.id;\r\n    }\r\n\r\n    /**\r\n     * Set Block ID\r\n     *\r\n     * @returns string\r\n     * @memberof Block\r\n     */\r\n    public setID(id: string): Block {\r\n        this.id = id;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get the name of the Block\r\n     *\r\n     * @returns string\r\n     * @memberof Block\r\n     */\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new Block Intent Class\r\n *\r\n * @export\r\n * @class BlockIntent\r\n * @extends {ManagerItem}\r\n */\r\nexport class BlockIntent extends ManagerItem {\r\n    /**\r\n     * The name of the Block\r\n     *\r\n     * @protected\r\n     * @type string\r\n     * @memberof BlockIntent\r\n     */\r\n    protected name: string;\r\n\r\n    /**\r\n     * The Block Class\r\n     *\r\n     * @protected\r\n     * @type {Promise<typeof Block>}\r\n     * @memberof BlockIntent\r\n    */\r\n    protected block: Promise<typeof Block>;\r\n\r\n    /**\r\n     * Creates an instance of BlockIntent.\r\n     *\r\n     * @param {{ name: string; block: typeof Block; }} { name, block }\r\n     * @memberof BlockIntent\r\n     */\r\n    constructor({ name, block }: { name: string; block: Promise<typeof Block> | typeof Block; }) {\r\n        super();\r\n        this.name = name;\r\n        this.block = block instanceof Promise ? block : Promise.resolve(block);\r\n    }\r\n\r\n    /**\r\n     * Getter for name of Block Intent\r\n     *\r\n     * @returns string\r\n     * @memberof BlockIntent\r\n     */\r\n    public getName(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Getter for the Block of the Block Intent\r\n     *\r\n     * @returns {Promise<typeof Block>}\r\n     * @memberof BlockIntent\r\n     */\r\n    public getBlock(): Promise<typeof Block> {\r\n        return this.block;\r\n    }\r\n}\r\n\r\n/**\r\n * A Service Manager designed to handle only Block Services, it refreshes on Page Change\r\n *\r\n * @export\r\n * @class BlockManager\r\n * @extends {AdvancedManager<number, BlockIntent>}\r\n */\r\nexport class BlockManager extends AdvancedManager<number, BlockIntent> {\r\n    /**\r\n     * A list of Active Blocks\r\n     *\r\n     * @protected\r\n     * @type {Manager<string, AdvancedManager<string, Block>>}\r\n     * @memberof BlockManager\r\n     */\r\n    protected activeBlocks: Manager<string, AdvancedManager<number, Block>> = new Manager();\r\n\r\n    /**\r\n     * An Array of ID's\r\n     *\r\n     * @protected\r\n     * @type {Manager<string, string>}\r\n     * @memberof BlockManager\r\n     */\r\n    protected activeIDs: Manager<string, string[]> = new Manager();\r\n\r\n    /**\r\n     * Observes any changes to the page, and updates blocks based on this information\r\n     *\r\n     * @protected\r\n     * @type {MutationObserver}\r\n     * @memberof BlockManager\r\n     */\r\n    protected domObserver: MutationObserver;\r\n\r\n    /**\r\n     * Creates an instance of BlockManager.\r\n     *\r\n     * @param {App} app\r\n     * @memberof BlockManager\r\n     */\r\n    constructor(app: App) {\r\n        super(app);\r\n    }\r\n\r\n    /**\r\n     * Initialize all Blocks\r\n     *\r\n     * @memberof BlockManager\r\n     */\r\n    public async init() {\r\n        let app = this.getApp();\r\n        for (let [, intent] of this) {\r\n            let name: string = intent.getName();\r\n            let selector: string = `[${this.getConfig(\"blockAttr\", false)}=\"${name}\"]`;\r\n            let rootElements: Node[] = [\r\n                ...document.querySelectorAll(selector),\r\n            ];\r\n\r\n            let idList = [];\r\n            let manager: AdvancedManager<number, Block> = new AdvancedManager(app);\r\n            let block: typeof Block = await intent.getBlock();\r\n            for (let i = 0, len = rootElements.length; i < len; i++) {\r\n                let rootElement = rootElements[i] as HTMLElement;\r\n                let id = rootElement.id;\r\n                let newInstance: Block = new block();\r\n                newInstance.init({ name, rootElement, selector, index: i });\r\n                newInstance.setID(id);\r\n\r\n                idList[i] = id;\r\n                manager.set(i, newInstance);\r\n            }\r\n\r\n            this.activeIDs[name] = idList;\r\n            this.activeBlocks.set(name, manager);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Refreshes DOM Elements\r\n     *\r\n     * @memberof BlockManager\r\n     */\r\n    public async update() {\r\n        let app = this.getApp();\r\n        for (let [, intent] of this) {\r\n            let name: string = intent.getName();\r\n            let selector: string = `[${this.getConfig(\"blockAttr\", false)}=\"${name}\"]`;\r\n            let rootElements: Node[] = [\r\n                ...document.querySelectorAll(selector),\r\n            ];\r\n\r\n            let idList = [];\r\n            let manager: AdvancedManager<number, Block> = new AdvancedManager(app);\r\n            let block: typeof Block = await intent.getBlock();\r\n            for (let i = 0, len = rootElements.length; i < len; i++) {\r\n                let rootElement = rootElements[i] as HTMLElement;\r\n                let id = rootElement.id;\r\n                if (this.activeIDs[name][i] !== id) {\r\n                    let newInstance: Block = new block();\r\n                    newInstance.init({ name, rootElement, selector, index: i });\r\n                    newInstance.setID(id);\r\n                    newInstance.boot();\r\n\r\n                    idList[i] = id;\r\n                    manager.set(i, newInstance);\r\n                }\r\n            }\r\n\r\n            this.activeIDs[name] = idList;\r\n            this.activeBlocks.set(name, manager);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Call the initEvents method for all Blocks\r\n     *\r\n     * @returns BlockManager\r\n     * @memberof BlockManager\r\n     */\r\n    public initEvents(): BlockManager {\r\n        for (let [, blockManager] of this.activeBlocks) {\r\n            blockManager.methodCall(\"initEvents\");\r\n        }\r\n        let app = this.getApp();\r\n        let rootElement = app.getPages().last().getWrapper();\r\n\r\n        this.update = this.update.bind(this);\r\n        this.domObserver = new window.MutationObserver(this.update);\r\n        this.observe(rootElement);\r\n\r\n        const EventEmitter = app.getEmitter();\r\n        EventEmitter.on(\"BEFORE_TRANSITION_IN\", async () => {\r\n            rootElement = app.getPages().last().getWrapper();\r\n            this.domObserver.disconnect();\r\n            this.refresh();\r\n\r\n            await this.init();\r\n            this.boot();\r\n            this.observe(rootElement);\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Observe any changes to elements and update based on that\r\n     *\r\n     * @param {HTMLElement} rootElement\r\n     * @memberof BlockManager\r\n     */\r\n    public observe(rootElement: HTMLElement) {\r\n        this.domObserver.observe(rootElement, {\r\n            childList: true,\r\n            attributes: false,\r\n            characterData: false,\r\n            subtree: true,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Call the boot method for all Blocks\r\n     *\r\n     * @returns BlockManager\r\n     * @memberof BlockManager\r\n     */\r\n    public boot(): BlockManager {\r\n        for (let [, blockManager] of this.activeBlocks) {\r\n            blockManager.methodCall(\"boot\");\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Refreshes the active blocks list\r\n     *\r\n     * @returns {BlockManager}\r\n     * @memberof BlockManager\r\n     */\r\n    public refresh(): BlockManager {\r\n        for (let [, blockManager] of this.activeBlocks) {\r\n            blockManager.methodCall(\"stop\");\r\n        }\r\n        this.activeBlocks.clear();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Call the stop method for all Blocks\r\n     *\r\n     * @returns BlockManager\r\n     * @memberof BlockManager\r\n     */\r\n    public stop(): BlockManager {\r\n        this.refresh();\r\n        this.stopEvents();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Call the stopEvents method for all Blocks\r\n     *\r\n     * @returns BlockManager\r\n     * @memberof BlockManager\r\n     */\r\n    public stopEvents(): BlockManager {\r\n        for (let [, blockManager] of this.activeBlocks) {\r\n            blockManager.methodCall(\"stopEvents\");\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Getter for activeBlocks in BlockManager\r\n     *\r\n     * @returns {Manager<string, AdvancedManager<number, Block>>}\r\n     * @memberof BlockManager\r\n     */\r\n    public getActiveBlocks(): Manager<string, AdvancedManager<number, Block>> {\r\n        return this.activeBlocks;\r\n    }\r\n}","import { EventEmitter, ListenerCallback, EventInput } from \"./emitter\";\r\nimport { TransitionManager, Transition } from \"./transition\";\r\nimport { BlockManager, BlockIntent, Block } from \"./block\";\r\nimport { HistoryManager, State, IState } from \"./history\";\r\nimport { ServiceManager, Service } from \"./service\";\r\nimport { PageManager, Page } from \"./page\";\r\nimport { CONFIG, ICONFIG } from \"./config\";\r\n\r\n/**\r\n * The App class starts the entire process, it controls all managers and all services\r\n *\r\n * @export\r\n * @class App\r\n */\r\nexport class App {\r\n    /**\r\n     * A new instance of the HistoryManager\r\n     *\r\n     * @protected\r\n     * @type HistoryManager\r\n     * @memberof App\r\n     */\r\n    protected history: HistoryManager;\r\n\r\n    /**\r\n     * A new instance of the TransitionManager\r\n     *\r\n     * @protected\r\n     * @type TransitionManager\r\n     * @memberof App\r\n     */\r\n    protected transitions: TransitionManager;\r\n\r\n    /**\r\n     * A new instance of the ServiceManager\r\n     *\r\n     * @protected\r\n     * @type ServiceManager\r\n     * @memberof App\r\n     */\r\n    protected services: ServiceManager;\r\n\r\n    /**\r\n     * A new instance of the BlockManager\r\n     *\r\n     * @protected\r\n     * @type BlockManager\r\n     * @memberof App\r\n     */\r\n    protected blocks: BlockManager;\r\n\r\n    /**\r\n     * A new instance of an EventEmitter\r\n     *\r\n     * @protected\r\n     * @type EventEmitter\r\n     * @memberof App\r\n     */\r\n    protected emitter: EventEmitter;\r\n\r\n    /**\r\n     * A new instance of the PageManager\r\n     *\r\n     * @protected\r\n     * @type PageManager\r\n     * @memberof App\r\n     */\r\n    protected pages: PageManager;\r\n\r\n    /**\r\n     * The current Configuration's for the framework\r\n     *\r\n     * @protected\r\n     * @type CONFIG\r\n     * @memberof App\r\n     */\r\n    protected config: CONFIG;\r\n\r\n    /**\r\n     * Creates an instance of App.\r\n     *\r\n     * @param {(ICONFIG | CONFIG)} [config={}]\r\n     * @memberof App\r\n     */\r\n    constructor(config: object = {}) {\r\n        this.register(config);\r\n    }\r\n\r\n    /**\r\n     * For registering all managers and the configurations\r\n     *\r\n     * @param {(ICONFIG | CONFIG)} [config={}]\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public register(config: ICONFIG | CONFIG = {}): App {\r\n        this.config = config instanceof CONFIG ? config : new CONFIG(config);\r\n        this.transitions = new TransitionManager(this);\r\n        this.services = new ServiceManager(this);\r\n        this.blocks = new BlockManager(this);\r\n        this.history = new HistoryManager();\r\n        this.pages = new PageManager(this);\r\n        this.emitter = new EventEmitter();\r\n\r\n        let handler = (() => {\r\n            document.removeEventListener(\"DOMContentLoaded\", handler);\r\n            window.removeEventListener(\"load\", handler);\r\n            this.emitter.emit(\"READY ready\");\r\n        }).bind(this);\r\n\r\n        document.addEventListener(\"DOMContentLoaded\", handler);\r\n        window.addEventListener(\"load\", handler);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the current configurations for the framework\r\n     *\r\n     * @param {...any} args\r\n     * @returns any\r\n     * @memberof App\r\n     */\r\n    public getConfig(...args: any): any {\r\n        return this.config.getConfig(...args);\r\n    }\r\n\r\n    /**\r\n     * Return the App's EventEmitter\r\n     *\r\n     * @returns EventEmitter\r\n     * @memberof App\r\n     */\r\n    public getEmitter(): EventEmitter {\r\n        return this.emitter;\r\n    }\r\n\r\n    /**\r\n     * Returns the App's BlockManager\r\n     *\r\n     * @returns BlockManager\r\n     * @memberof App\r\n     */\r\n    public getBlocks(): BlockManager {\r\n        return this.blocks;\r\n    }\r\n\r\n    /**\r\n     * Return the App's ServiceManager\r\n     *\r\n     * @returns ServiceManager\r\n     * @memberof App\r\n     */\r\n    public getServices(): ServiceManager {\r\n        return this.services;\r\n    }\r\n\r\n    /**\r\n     * Return the App's PageManager\r\n     *\r\n     * @returns PageManager\r\n     * @memberof App\r\n     */\r\n    public getPages(): PageManager {\r\n        return this.pages;\r\n    }\r\n\r\n    /**\r\n     * Return the App's TransitionManager\r\n     *\r\n     * @returns TransitionManager\r\n     * @memberof App\r\n     */\r\n    public getTransitions(): TransitionManager {\r\n        return this.transitions;\r\n    }\r\n\r\n    /**\r\n     * Return the App's HistoryManager\r\n     *\r\n     * @returns HistoryManager\r\n     * @memberof App\r\n     */\r\n    public getHistory(): HistoryManager {\r\n        return this.history;\r\n    }\r\n\r\n    /**\r\n     * Returns a Block Intent Object from the App's instance of the BlockManager\r\n     *\r\n     * @param {number} key\r\n     * @returns IBlockIntent\r\n     * @memberof App\r\n     */\r\n    public getBlock(key: number): BlockIntent {\r\n        return this.blocks.get(key);\r\n    }\r\n\r\n    /**\r\n     * Returns an instance of a Block from the App's instance of the BlockManager\r\n     *\r\n     * @param {string} name\r\n     * @param {number} key\r\n     * @returns Block\r\n     * @memberof App\r\n     */\r\n    public getActiveBlock(name: string, key: number): Block {\r\n        return this.blocks.getActiveBlocks().get(name).get(key);\r\n    }\r\n\r\n    /**\r\n     * Returns a Service from the App's instance of the ServiceManager\r\n     *\r\n     * @param {number} key\r\n     * @returns Service\r\n     * @memberof App\r\n     */\r\n    public getService(key: number): Service {\r\n        return this.services.get(key);\r\n    }\r\n\r\n    /**\r\n     * Returns a Transition from the App's instance of the TransitionManager\r\n     *\r\n     * @param {string} key\r\n     * @returns Transition\r\n     * @memberof App\r\n     */\r\n    public getTransition(key: string): Transition {\r\n        return this.transitions.get(key);\r\n    }\r\n\r\n    /**\r\n     * Returns a State from the App's instance of the HistoryManager\r\n     *\r\n     * @param {number} key\r\n     * @returns State\r\n     * @memberof App\r\n     */\r\n    public getState(key: number): State {\r\n        return this.history.get(key);\r\n    }\r\n\r\n    /**\r\n     * Based on the type, it will return either a Transition, a Service, or a State from their respective Managers\r\n     *\r\n     * @param {(\"service\" | \"transition\" | \"state\" | string)} type\r\n     * @param {any} key\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public get(type: \"service\" | \"transition\" | \"state\" | string, key: any): App {\r\n        switch (type.toLowerCase()) {\r\n            case \"service\":\r\n                this.getService(key);\r\n                break;\r\n            case \"transition\":\r\n                this.getTransition(key);\r\n                break;\r\n            case \"state\":\r\n                this.getState(key);\r\n                break;\r\n            default:\r\n                throw `Error: can't get type '${type}', it is not a recognized type. Did you spell it correctly.`;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a Page\r\n     *\r\n     * @param {string} url\r\n     * @returns Promise<Page>\r\n     * @memberof App\r\n     */\r\n    public async loadPage(url: string): Promise<Page> {\r\n        return await this.pages.load(url);\r\n    }\r\n\r\n    /**\r\n     * Based on the type, it will return load a Transition, a Service, a State, or a Page from their respective Managers\r\n     *\r\n     * @param {(\"page\" | string)} type\r\n     * @param {any} key\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public async load(type: \"page\" | string, key: any): Promise<any> {\r\n        switch (type.toLowerCase()) {\r\n            case \"page\":\r\n                return await this.loadPage(key);\r\n            default:\r\n                return Promise.resolve(this.get(type, key));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a Block Intent to the App's instance of the BlockManager\r\n     *\r\n     * @param {BlockIntent} blockIntent\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public addBlock(blockIntent: BlockIntent): App {\r\n        this.blocks.add(blockIntent);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a Service to the App's instance of the ServiceManager\r\n     *\r\n     * @param {Service} service\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public addService(service: Service): App {\r\n        this.services.add(service);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a Transition to the App's instance of the TransitionManager\r\n     *\r\n     * @param {Transition} transition\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public addTransition(transition: Transition): App {\r\n        this.transitions.add(transition);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a State to the App's instance of the HistoryManager\r\n     *\r\n     * @param {(IState | State)} state\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public addState(state: IState | State): App {\r\n        this.history.addState(state);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Based on the type, it will add either a Transition, a Service, or a State to their respective Managers\r\n     *\r\n     * @param {(\"service\" | \"transition\" | \"state\")} type\r\n     * @param {any} value\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public add(type: \"service\" | \"transition\" | \"state\" | \"block\", value: any): App {\r\n        switch (type.toLowerCase()) {\r\n            case \"service\":\r\n                this.addService(value);\r\n                break;\r\n            case \"transition\":\r\n                this.addTransition(value);\r\n                break;\r\n            case \"state\":\r\n                this.addState(value);\r\n                break;\r\n            case \"block\":\r\n                this.addBlock(value);\r\n                break;\r\n            default:\r\n                throw `Error: can't add type '${type}', it is not a recognized type. Did you spell it correctly.`;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Start the App and the ServiceManager\r\n     *\r\n     * @returns Promise<App>\r\n     * @memberof App\r\n     */\r\n    public async boot(): Promise<App> {\r\n        await this.blocks.init();\r\n        this.services.boot();\r\n        this.services.initEvents();\r\n\r\n        this.blocks.boot();\r\n        this.blocks.initEvents();\r\n\r\n        this.transitions.initEvents();\r\n        return Promise.resolve(this);\r\n    }\r\n\r\n    /**\r\n     * Stop the App and the ServiceManager\r\n     *\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public stop(): App {\r\n        this.services.stop();\r\n        this.blocks.stop();\r\n        this.transitions.stopEvents();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the current page in the PageManager\r\n     *\r\n     * @returns Page\r\n     * @memberof App\r\n     */\r\n    public currentPage(): Page {\r\n        let currentState = this.history.last();\r\n        return this.pages.get(currentState.getURLPathname());\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter on method\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback} callback\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public on(events: EventInput, callback?: ListenerCallback): App {\r\n        this.emitter.on(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter off method\r\n     *\r\n     * @param {EventInput} events\r\n     * @param {ListenerCallback} callback\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public off(events: EventInput, callback?: ListenerCallback): App {\r\n        this.emitter.off(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter once method\r\n     *\r\n     * @param {string} events\r\n     * @param {ListenerCallback} callback\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public once(events: string, callback: ListenerCallback): App {\r\n        this.emitter.once(events, callback, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A shortcut to the App EventEmitter emit method\r\n     *\r\n     * @param {(string | any[])} events\r\n     * @param {...any} args\r\n     * @returns App\r\n     * @memberof App\r\n     */\r\n    public emit(events: string | any[], ...args: any): App {\r\n        this.emitter.emit(events, ...args);\r\n        return this;\r\n    }\r\n}\r\n","import { State, Trigger, IState, Coords } from \"./history\";\r\nimport { Service } from \"./service\";\r\nimport { Page } from \"./page\";\r\nimport { _URL } from \"./url\";\r\n\r\nexport type LinkEvent = MouseEvent | TouchEvent;\r\nexport type StateEvent = LinkEvent | PopStateEvent;\r\nexport type IgnoreURLsList = Array<RegExp | string>;\r\n\r\n/**\r\n * Creates a Barba JS like PJAX Service, for the Framework\r\n *\r\n * @export\r\n * @class PJAX\r\n * @extends {Service}\r\n */\r\n// Based on Barba JS and StartingBlocks\r\nexport class PJAX extends Service {\r\n    /**\r\n     * URLs to ignore when prefetching\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected ignoreURLs: IgnoreURLsList = [];\r\n\r\n    /**\r\n     * Whether or not to disable prefetching\r\n     *\r\n     * @private\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    protected prefetchIgnore: boolean = false;\r\n\r\n    /**\r\n     * Current state or transitions\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected isTransitioning: boolean = false;\r\n\r\n    /**\r\n     * Ignore extra clicks of an anchor element if a transition has already started\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected stopOnTransitioning: boolean = false;\r\n\r\n    /**\r\n     * On page change (excluding popstate event) keep current scroll position\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected stickyScroll: boolean = true;\r\n\r\n    /**\r\n     * Force load a page if an error occurs\r\n     *\r\n     * @private\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected forceOnError: boolean = false;\r\n\r\n    /**\r\n     * Dictates whether to auto scroll if an hash is present in the window URL\r\n     *\r\n     * @protected\r\n     * @type boolean\r\n     * @memberof PJAX\r\n     */\r\n    protected autoScrollOnHash: boolean = true;\r\n\r\n    /**\r\n     * Sets the transition state, sets isTransitioning to true\r\n     *\r\n     * @private\r\n     * @memberof PJAX\r\n     */\r\n    private transitionStart() {\r\n        this.isTransitioning = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the transition state, sets isTransitioning to false\r\n     *\r\n     * @private\r\n     * @memberof PJAX\r\n     */\r\n    private transitionStop() {\r\n        this.isTransitioning = false;\r\n    }\r\n\r\n    /**\r\n     * Starts the PJAX Service\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public boot() {\r\n        let current = new State();\r\n        this.HistoryManager.add(current);\r\n        this.changeState(\"replace\", current);\r\n    }\r\n\r\n    /**\r\n     * Gets the transition to use for a certain anchor\r\n     *\r\n     * @param {HTMLAnchorElement} el\r\n     * @returns {(string | null)}\r\n     * @memberof PJAX\r\n     */\r\n    public getTransitionName(el: HTMLAnchorElement): string | null {\r\n        if (!el || !el.getAttribute) return null;\r\n        let transitionAttr = el.getAttribute(this.getConfig(\"transitionAttr\", false));\r\n        if (typeof transitionAttr === 'string')\r\n            return transitionAttr;\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the anchor is valid\r\n     *\r\n     * @param {HTMLAnchorElement} el\r\n     * @param {(LinkEvent | KeyboardEvent)} event\r\n     * @param {string} href\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public validLink(el: HTMLAnchorElement, event: LinkEvent | KeyboardEvent, href: string): boolean {\r\n        let pushStateSupport = !window.history.pushState;\r\n        let exists = !el || !href;\r\n        let eventMutate =\r\n            (event as KeyboardEvent).which > 1 ||\r\n            (event as KeyboardEvent).metaKey ||\r\n            (event as KeyboardEvent).ctrlKey ||\r\n            (event as KeyboardEvent).shiftKey ||\r\n            (event as KeyboardEvent).altKey;\r\n        let newTab = el.hasAttribute('target') && (el as HTMLAnchorElement).target === '_blank';\r\n        let crossOrigin =\r\n            ((el as HTMLAnchorElement).protocol !== location.protocol) ||\r\n            ((el as HTMLAnchorElement).hostname !== location.hostname);\r\n        let download = typeof el.getAttribute('download') === 'string';\r\n        let preventSelf = el.hasAttribute(this.getConfig(\"preventSelfAttr\", false));\r\n        let preventAll = Boolean(\r\n            el.closest(this.getConfig(\"preventAllAttr\"))\r\n        );\r\n        let prevent = preventSelf && preventAll;\r\n        let sameURL = new _URL().getFullPath() === new _URL(href).getFullPath();\r\n        return !(exists || pushStateSupport || eventMutate || newTab || crossOrigin || download || prevent || sameURL);\r\n    }\r\n\r\n    /**\r\n     * Returns the href or an Anchor element\r\n     *\r\n     * @param {HTMLAnchorElement} el\r\n     * @returns {(string | null)}\r\n     * @memberof PJAX\r\n     */\r\n    public getHref(el: HTMLAnchorElement): string | null {\r\n        if (el && el.tagName && el.tagName.toLowerCase() === 'a' && typeof el.href === 'string')\r\n            return el.href;\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if event target is a valid anchor with an href, if so, return the link\r\n     *\r\n     * @param {LinkEvent} event\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public getLink(event: LinkEvent): HTMLAnchorElement {\r\n        let el = event.target as HTMLAnchorElement;\r\n        let href: string = this.getHref(el);\r\n\r\n        while (el && !href) {\r\n            el = (el as HTMLElement).parentNode as HTMLAnchorElement;\r\n            href = this.getHref(el);\r\n        }\r\n\r\n        // Check for a valid link\r\n        if (!el || !this.validLink(el, event, href)) return;\r\n        return el;\r\n    }\r\n\r\n    /**\r\n     * When an element is clicked.\r\n     *\r\n     * Get valid anchor element.\r\n     * Go for a transition.\r\n     *\r\n     * @param {LinkEvent} event\r\n     * @returns\r\n     * @memberof PJAX\r\n     */\r\n    public onClick(event: LinkEvent) {\r\n        let el = this.getLink(event);\r\n        if (!el) return;\r\n\r\n        if (this.isTransitioning && this.stopOnTransitioning) {\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n            return;\r\n        }\r\n\r\n        let href = this.getHref(el);\r\n        this.EventEmitter.emit(\"ANCHOR_CLICK CLICK\", event);\r\n        this.go({ href, trigger: el, event });\r\n    }\r\n\r\n    /**\r\n     * Returns the direction of the State change as a String, either the Back button or the Forward button\r\n     *\r\n     * @param {number} value\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public getDirection(value: number): Trigger {\r\n        if (Math.abs(value) > 1) {\r\n            // Ex 6-0 > 0 -> forward, 0-6 < 0 -> back\r\n            return value > 0 ? 'forward' : 'back';\r\n        } else {\r\n            if (value === 0) {\r\n                return 'popstate';\r\n            } else {\r\n                // Ex 6-5 > 0 -> back, 5-6 < 0 -> forward\r\n                return value > 0 ? 'back' : 'forward';\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force a page to go to a certain URL\r\n     *\r\n     * @param {string} href\r\n     * @memberof PJAX\r\n     */\r\n    public force(href: string): void {\r\n        window.location.assign(href);\r\n    }\r\n\r\n    /**\r\n     * If transition is running force load page.\r\n     * Stop if currentURL is the same as new url.\r\n     * On state change, change the current state history,\r\n     * to reflect the direction of said state change\r\n     * Load page and page transition.\r\n     *\r\n     * @param {string} href\r\n     * @param {Trigger} [trigger='HistoryManager']\r\n     * @param {StateEvent} [event]\r\n     * @memberof PJAX\r\n     */\r\n    public go({ href, trigger = 'HistoryManager', event }: { href: string; trigger?: Trigger; event?: StateEvent; }): Promise<void> {\r\n        // If transition is already running and the go method is called again, force load page\r\n        if (this.isTransitioning && this.stopOnTransitioning) {\r\n            this.force(href);\r\n            return;\r\n        }\r\n\r\n        let url = new _URL(href);\r\n        let currentState = this.HistoryManager.last();\r\n        let currentURL = currentState.getURL();\r\n        if (currentURL.equalTo(url)) {\r\n            this.hashAction(url.hash);\r\n            return;\r\n        }\r\n\r\n        let transitionName: string;\r\n        if (event && (event as PopStateEvent).state) {\r\n            this.EventEmitter.emit(\"POPSTATE\", event);\r\n\r\n            // If popstate, get back/forward direction.\r\n            let { state }: { state: IState } = event as PopStateEvent;\r\n            let { index, transition, data } = state;\r\n            let currentIndex = currentState.getIndex();\r\n            let difference = currentIndex - index;\r\n\r\n            trigger = this.getDirection(difference);\r\n            transitionName = transition;\r\n\r\n            // If page remains the same on state change DO NOT run this, it's pointless\r\n            if (trigger !== \"popstate\") {\r\n                // Keep scroll position\r\n                let { x, y } = data.scroll;\r\n                window.scroll({\r\n                    top: y, left: x,\r\n                    behavior: 'smooth'  //  \r\n                });\r\n            }\r\n\r\n            // Based on the direction of the state change either remove or add a state\r\n            if (trigger === \"back\") {\r\n                this.HistoryManager.delete(currentIndex);\r\n                this.EventEmitter.emit(`POPSTATE_BACK`, event);\r\n            } else if (trigger === \"forward\") {\r\n                this.HistoryManager.addState({ url, transition, data });\r\n                this.EventEmitter.emit(`POPSTATE_FORWARD`, event);\r\n            }\r\n        } else {\r\n            // Add new state\r\n            transitionName = this.getTransitionName(trigger as HTMLAnchorElement) || \"default\";\r\n            const scroll = new Coords();\r\n            const index = this.HistoryManager.size;\r\n            const state = new State({\r\n                url, index,\r\n                transition: transitionName,\r\n                data: { scroll }\r\n            });\r\n\r\n            if (this.stickyScroll) {\r\n                // Keep scroll position\r\n                let { x, y } = scroll;\r\n                window.scroll({\r\n                    top: y, left: x,\r\n                    behavior: 'smooth'  //  \r\n                });\r\n            } else {\r\n                window.scroll({\r\n                    top: 0, left: 0,\r\n                    behavior: 'smooth'  //  \r\n                });\r\n            }\r\n\r\n            this.HistoryManager.add(state);\r\n            this.changeState(\"push\", state);\r\n            this.EventEmitter.emit(\"HISTORY_NEW_ITEM\", event);\r\n        }\r\n\r\n        if (event) {\r\n            event.stopPropagation();\r\n            event.preventDefault();\r\n        }\r\n\r\n        this.EventEmitter.emit(\"GO\", event);\r\n        return this.load({ oldHref: currentURL.getPathname(), href, trigger, transitionName });\r\n    }\r\n\r\n    /**\r\n     * Either push or replace history state\r\n     *\r\n     * @param {(\"push\" | \"replace\")} action\r\n     * @param {IState} state\r\n     * @param {_URL} url\r\n     * @memberof PJAX\r\n     */\r\n    public changeState(action: \"push\" | \"replace\", state: State) {\r\n        let url = state.getURL();\r\n        let href = url.getFullPath();\r\n        let json = state.toJSON();\r\n        let args = [json, '', href];\r\n        if (window.history) {\r\n            switch (action) {\r\n                case 'push':\r\n                    window.history.pushState.apply(window.history, args);\r\n                    break;\r\n                case 'replace':\r\n                    window.history.replaceState.apply(window.history, args);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the new Page as well as a Transition; run the Transition\r\n     *\r\n     * @param {string} oldHref\r\n     * @param {string} href\r\n     * @param {Trigger} trigger\r\n     * @param {string} [transitionName=\"default\"]\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public async load({ oldHref, href, trigger, transitionName = \"default\" }: { oldHref: string; href: string; trigger: Trigger; transitionName?: string; }): Promise<any> {\r\n        try {\r\n            let oldPage = this.PageManager.get(oldHref);\r\n            let newPage: Page;\r\n\r\n            this.EventEmitter.emit(\"PAGE_LOADING\", { href, oldPage, trigger });\r\n            try {\r\n                try {\r\n                    newPage = await this.PageManager.load(href);\r\n                    this.transitionStart();\r\n                    this.EventEmitter.emit(\"PAGE_LOAD_COMPLETE\", { newPage, oldPage, trigger });\r\n                } catch (err) {\r\n                    throw `[PJAX] Page load error: ${err}`;\r\n                }\r\n\r\n                // --\r\n                // --\r\n\r\n                this.EventEmitter.emit(\"NAVIGATION_START\", { oldPage, newPage, trigger, transitionName });\r\n                try {\r\n                    this.EventEmitter.emit(\"TRANSITION_START\", transitionName);\r\n\r\n                    let transition = await this.TransitionManager.boot({\r\n                        name: transitionName,\r\n                        oldPage,\r\n                        newPage,\r\n                        trigger\r\n                    });\r\n\r\n                    this.hashAction();\r\n                    this.EventEmitter.emit(\"TRANSITION_END\", { transition });\r\n                } catch (err) {\r\n                    throw `[PJAX] Transition error: ${err}`;\r\n                }\r\n\r\n                this.EventEmitter.emit(\"NAVIGATION_END\", { oldPage, newPage, trigger, transitionName });\r\n            } catch (err) {\r\n                this.transitionStop();\r\n                throw err;\r\n            }\r\n\r\n            this.transitionStop(); // Sets isTransitioning to false\r\n        } catch (err) {\r\n            if (this.forceOnError) this.force(href);\r\n            else console.error(err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Auto scrolls to an elements position if the element has an hash\r\n     *\r\n     * @param {string} [hash=window.location.hash]\r\n     * @memberof PJAX\r\n     */\r\n    public hashAction(hash: string = window.location.hash) {\r\n        if (this.autoScrollOnHash) {\r\n            let hashID = hash.slice(1);\r\n\r\n            if (hashID.length) {\r\n                let el = document.getElementById(hashID);\r\n\r\n                if (el) {\r\n                    if (el.scrollIntoView) {\r\n                        el.scrollIntoView({ behavior: 'smooth' });\r\n                    } else {\r\n                        let { left, top } = el.getBoundingClientRect();\r\n                        window.scroll({ left, top, behavior: 'smooth' });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check to see if the URL is to be ignored, uses either RegExp of Strings to check\r\n     *\r\n     * @param {_URL} { pathname }\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public ignoredURL({ pathname }: _URL): boolean {\r\n        return this.ignoreURLs.length && this.ignoreURLs.some(url => {\r\n            return typeof url === \"string\" ? url === pathname : (url as RegExp).exec(pathname) !== null;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * When you hover over an anchor, prefetch the event target's href\r\n     *\r\n     * @param {LinkEvent} event\r\n     * @memberof PJAX\r\n     */\r\n    public onHover(event: LinkEvent): Promise<void> {\r\n        let el = this.getLink(event);\r\n        if (!el) return;\r\n\r\n        const url = new _URL(this.getHref(el));\r\n        const urlString: string = url.getPathname();\r\n        // If Url is ignored or already in cache, don't do any think\r\n        if (this.ignoredURL(url) || this.PageManager.has(urlString)) return;\r\n\r\n        this.EventEmitter.emit(\"ANCHOR_HOVER HOVER hover\", event);\r\n\r\n        (async () => {\r\n            try {\r\n                await this.PageManager.load(url);\r\n            } catch (err) {\r\n                console.warn(\"[PJAX] Prefetch error: \", err);\r\n            }\r\n        })();\r\n    }\r\n\r\n    /**\r\n     * When History state changes.\r\n     *\r\n     * Get url from State\r\n     * Go for a Barba transition.\r\n     *\r\n     * @param {PopStateEvent} event\r\n     * @memberof PJAX\r\n     */\r\n    public onStateChange(event: PopStateEvent): void {\r\n        this.go({ href: window.location.href, trigger: 'popstate', event });\r\n    }\r\n\r\n    /**\r\n     * Bind the event listeners to the PJAX class\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public bindEvents() {\r\n        this.onHover = this.onHover.bind(this);\r\n        this.onClick = this.onClick.bind(this);\r\n        this.onStateChange = this.onStateChange.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Initialize DOM Events\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public initEvents() {\r\n        this.bindEvents();\r\n\r\n        if (this.prefetchIgnore !== true) {\r\n            document.addEventListener('mouseover', this.onHover);\r\n            document.addEventListener('touchstart', this.onHover);\r\n        }\r\n\r\n        document.addEventListener('click', this.onClick);\r\n        window.addEventListener('popstate', this.onStateChange);\r\n    }\r\n\r\n    /**\r\n     * Stop DOM Events\r\n     *\r\n     * @memberof PJAX\r\n     */\r\n    public stopEvents() {\r\n        if (this.prefetchIgnore !== true) {\r\n            document.removeEventListener('mouseover', this.onHover);\r\n            document.removeEventListener('touchstart', this.onHover);\r\n        }\r\n\r\n        document.removeEventListener('click', this.onClick);\r\n        window.removeEventListener('popstate', this.onStateChange);\r\n    }\r\n}","import { Service } from \"./service\";\r\nimport { Manager } from \"./manager\";\r\n\r\nexport type RouteMethod = (...args: any) => any;\r\nexport type RouteStyle = string | RegExp;\r\nexport interface IRouteToFrom {\r\n    to: RouteStyle,\r\n    from: RouteStyle\r\n}\r\nexport type RoutePath = IRouteToFrom | RouteStyle;\r\nexport interface IRoute {\r\n    path: RoutePath,\r\n    method: RouteMethod\r\n}\r\n\r\n/**\r\n * Controls what happens when certain url paths match a set of criteria\r\n *\r\n * @export\r\n * @class Router\r\n * @extends {Service}\r\n */\r\nexport class Router extends Service {\r\n    /**\r\n     * List of routes inputted\r\n     *\r\n     * @protected\r\n     * @type {Manager<IRouteToFrom, RouteMethod>}\r\n     * @memberof Router\r\n     */\r\n    protected routes: Manager<IRouteToFrom, RouteMethod>;\r\n\r\n    /**\r\n     * Creates an instance of Router.\r\n     * \r\n     * @param {Array<IRoute>} [routes=[]]\r\n     * @memberof Router\r\n     */\r\n    constructor(routes: IRoute[] = []) {\r\n        super();\r\n        this.routes = new Manager();\r\n        for (const route of routes) {\r\n            this.add(route);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new route to watch for\r\n     *\r\n     * @param {IRoute} { path, method }\r\n     * @returns {Router}\r\n     * @memberof Router\r\n     */\r\n    public add({ path, method }: IRoute): Router {\r\n        const key = this.parse(path);\r\n        this.routes.set(key, method);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Convert strings into path match functions\r\n     *\r\n     * @param {RouteStyle} path\r\n     * @returns {RegExp}\r\n     * @memberof Router\r\n     */\r\n    public parsePath(path: RouteStyle): RegExp {\r\n        if (typeof path === \"string\")\r\n            return new RegExp(path, \"i\");\r\n        else if (path instanceof RegExp)\r\n            return path;\r\n        throw \"[Router] only regular expressions and strings are accepted as paths.\";\r\n    }\r\n\r\n    /**\r\n     * Determines if a strings counts has a path\r\n     *\r\n     * @param {RouteStyle} input\r\n     * @returns boolean\r\n     * @memberof Router\r\n     */\r\n    public isPath(input: RouteStyle): boolean {\r\n        return typeof input === \"string\" || input instanceof RegExp;\r\n    }\r\n\r\n    /**\r\n     * Parse the multiple different formats for paths, into a { from, to } object\r\n     *\r\n     * @param {RouteStyle} input\r\n     * @returns {IRouteToFrom}\r\n     * @memberof Router\r\n     */\r\n    public parse(input: RoutePath): IRouteToFrom {\r\n        let route = (input as IRouteToFrom);\r\n        let toFromPath: IRouteToFrom = {\r\n            from: /(.*)/g,\r\n            to: /(.*)/g\r\n        };\r\n\r\n        if (this.isPath(input as RouteStyle))\r\n            toFromPath = {\r\n                from: input as RouteStyle,\r\n                to: /(.*)/g\r\n            };\r\n        else if (this.isPath(route.from) && this.isPath(route.to))\r\n            toFromPath = route;\r\n        else\r\n            throw \"[Router] path is neither a string, regular expression, or a { from, to } object.\";\r\n\r\n        let { from, to } = toFromPath;\r\n        return {\r\n            from: this.parsePath(from),\r\n            to: this.parsePath(to)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test if route paths are true, if so run their methods\r\n     *\r\n     * @memberof Router\r\n     */\r\n    public route() {\r\n        let from: string = this.HistoryManager.last().getURLPathname();\r\n        let to: string = window.location.pathname;\r\n\r\n        this.routes.forEach((method: RouteMethod, path: IRouteToFrom) => {\r\n            let fromRegExp = (path.from as RegExp);\r\n            let toRegExp = (path.to as RegExp);\r\n\r\n            if (fromRegExp.test(from) && toRegExp.test(to)) {\r\n                let fromExec = fromRegExp.exec(from);\r\n                let toExec = toRegExp.exec(to);\r\n\r\n                method({ from: fromExec, to: toExec });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add listeners for PJAX Events\r\n     *\r\n     * @memberof Router\r\n     */\r\n    public initEvents() {\r\n        this.route = this.route.bind(this);\r\n        this.EventEmitter.on(\"READY\", this.route);\r\n        this.EventEmitter.on(\"PAGE_LOADING\", this.route);\r\n    }\r\n}"],"names":[],"mappings":"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"}